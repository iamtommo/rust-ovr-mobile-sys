/* automatically generated by rust-bindgen */

pub const VRAPI_PRODUCT_VERSION: u32 = 1;
pub const VRAPI_MAJOR_VERSION: u32 = 1;
pub const VRAPI_MINOR_VERSION: u32 = 26;
pub const VRAPI_PATCH_VERSION: u32 = 0;
pub const VRAPI_BUILD_VERSION: u32 = 171664428;
pub const VRAPI_BUILD_DESCRIPTION: &'static [u8; 12usize] = b"Development\0";
pub const VRAPI_DRIVER_VERSION: u32 = 171664428;
pub const VRAPI_PI: f64 = 3.141592653589793;
pub const VRAPI_ZNEAR: f64 = 0.1;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNINativeInterface {
    _unused: [u8; 0],
}
pub type JNIEnv = *const JNINativeInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNIInvokeInterface {
    _unused: [u8; 0],
}
pub type JavaVM = *const JNIInvokeInterface;
pub type jobject = *mut ::std::os::raw::c_void;
#[doc = " Java details about an activity"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrJava_ {
    pub Vm: *mut JavaVM,
    pub Env: *mut JNIEnv,
    pub ActivityObject: jobject,
}
#[test]
fn bindgen_test_layout_ovrJava_() {
    assert_eq!(
        ::std::mem::size_of::<ovrJava_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrJava_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrJava_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrJava_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Vm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Env as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).ActivityObject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(ActivityObject)
        )
    );
}
#[doc = " Java details about an activity"]
pub type ovrJava = ovrJava_;
pub type ovrResult = ::std::os::raw::c_int;
#[repr(u32)]
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSuccessResult_ {
    ovrSuccess = 0,
    ovrSuccess_BoundaryInvalid = 1001,
}
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
pub use self::ovrSuccessResult_ as ovrSuccessResult;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrErrorResult_ {
    ovrError_MemoryAllocationFailure = -1000,
    ovrError_NotInitialized = -1004,
    ovrError_InvalidParameter = -1005,
    ovrError_DeviceUnavailable = -1010,
    ovrError_InvalidOperation = -1015,
    ovrError_UnsupportedDeviceType = -1050,
    ovrError_NoDevice = -1051,
    ovrError_NotImplemented = -1052,
    ovrResult_EnumSize = 2147483647,
}
pub use self::ovrErrorResult_ as ovrErrorResult;
#[doc = " A 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector2f_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ovrVector2f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector2f_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector2f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A 2D vector."]
pub type ovrVector2f = ovrVector2f_;
#[doc = " A 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector3f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ovrVector3f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector3f_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector3f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " A 3D vector."]
pub type ovrVector3f = ovrVector3f_;
#[doc = " A 4D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector4f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrVector4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector4f_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " A 4D vector."]
pub type ovrVector4f = ovrVector4f_;
#[doc = " Quaternion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrQuatf_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrQuatf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrQuatf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrQuatf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Quaternion."]
pub type ovrQuatf = ovrQuatf_;
#[doc = " Row-major 4x4 matrix."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMatrix4f_ {
    pub M: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_ovrMatrix4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrMatrix4f_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrMatrix4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMatrix4f_>())).M as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMatrix4f_),
            "::",
            stringify!(M)
        )
    );
}
#[doc = " Row-major 4x4 matrix."]
pub type ovrMatrix4f = ovrMatrix4f_;
#[doc = " Position and orientation together."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrPosef_ {
    pub Orientation: ovrQuatf,
    pub __bindgen_anon_1: ovrPosef___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrPosef___bindgen_ty_1 {
    pub Position: ovrVector3f,
    pub Translation: ovrVector3f,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ovrPosef___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Translation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Translation)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPosef_>())).Orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef_),
            "::",
            stringify!(Orientation)
        )
    );
}
#[doc = " Position and orientation together."]
pub type ovrPosef = ovrPosef_;
#[doc = " A rectangle with 2D size and position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrRectf_ {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_ovrRectf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRectf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrRectf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRectf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrRectf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " A rectangle with 2D size and position."]
pub type ovrRectf = ovrRectf_;
#[repr(u32)]
#[doc = " True or false."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrBooleanResult_ {
    VRAPI_FALSE = 0,
    VRAPI_TRUE = 1,
}
#[doc = " True or false."]
pub use self::ovrBooleanResult_ as ovrBooleanResult;
#[repr(u32)]
#[doc = " One of the user's eyes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrEye_ {
    VRAPI_EYE_LEFT = 0,
    VRAPI_EYE_RIGHT = 1,
    VRAPI_EYE_COUNT = 2,
}
#[doc = " One of the user's eyes."]
pub use self::ovrEye_ as ovrEye;
#[repr(u32)]
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrStructureType_ {
    VRAPI_STRUCTURE_TYPE_INIT_PARMS = 1,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS = 2,
    VRAPI_STRUCTURE_TYPE_FRAME_PARMS = 3,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS_VULKAN = 5,
}
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
pub use self::ovrStructureType_ as ovrStructureType;
impl ovrDeviceType_ {
    pub const VRAPI_DEVICE_TYPE_NOTE4: ovrDeviceType_ =
        ovrDeviceType_::VRAPI_DEVICE_TYPE_GEARVR_START;
}
impl ovrDeviceType_ {
    pub const VRAPI_DEVICE_TYPE_OCULUSGO: ovrDeviceType_ =
        ovrDeviceType_::VRAPI_DEVICE_TYPE_OCULUSGO_START;
}
#[repr(i32)]
#[doc = " A VR-capable device."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceType_ {
    VRAPI_DEVICE_TYPE_GEARVR_START = 0,
    VRAPI_DEVICE_TYPE_NOTE5 = 1,
    VRAPI_DEVICE_TYPE_S6 = 2,
    VRAPI_DEVICE_TYPE_S7 = 3,
    VRAPI_DEVICE_TYPE_NOTE7 = 4,
    VRAPI_DEVICE_TYPE_S8 = 5,
    VRAPI_DEVICE_TYPE_NOTE8 = 6,
    VRAPI_DEVICE_TYPE_NOTE7_FE = 7,
    VRAPI_DEVICE_TYPE_A8 = 8,
    VRAPI_DEVICE_TYPE_A8_PLUS = 9,
    VRAPI_DEVICE_TYPE_S9 = 10,
    VRAPI_DEVICE_TYPE_S9_PLUS = 11,
    VRAPI_DEVICE_TYPE_A8_STAR = 12,
    VRAPI_DEVICE_TYPE_NOTE9 = 13,
    VRAPI_DEVICE_TYPE_A9_2018 = 14,
    VRAPI_DEVICE_TYPE_S10 = 15,
    VRAPI_DEVICE_TYPE_GEARVR_END = 63,
    VRAPI_DEVICE_TYPE_OCULUSGO_START = 64,
    VRAPI_DEVICE_TYPE_MIVR_STANDALONE = 65,
    VRAPI_DEVICE_TYPE_OCULUSGO_END = 127,
    VRAPI_DEVICE_TYPE_OCULUSQUEST_START = 256,
    VRAPI_DEVICE_TYPE_OCULUSQUEST = 259,
    VRAPI_DEVICE_TYPE_OCULUSQUEST_END = 319,
    VRAPI_DEVICE_TYPE_UNKNOWN = -1,
}
#[doc = " A VR-capable device."]
pub use self::ovrDeviceType_ as ovrDeviceType;
#[repr(i32)]
#[doc = " A headset, which typically includes optics and tracking hardware, but not necessarily the device itself."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrHeadsetType_ {
    VRAPI_HEADSET_TYPE_R320 = 0,
    VRAPI_HEADSET_TYPE_R321 = 1,
    VRAPI_HEADSET_TYPE_R322 = 2,
    VRAPI_HEADSET_TYPE_R323 = 3,
    VRAPI_HEADSET_TYPE_R324 = 4,
    VRAPI_HEADSET_TYPE_R325 = 5,
    VRAPI_HEADSET_TYPE_OCULUSGO = 64,
    VRAPI_HEADSET_TYPE_MIVR_STANDALONE = 65,
    VRAPI_HEADSET_TYPE_OCULUSQUEST = 256,
    VRAPI_HEADSET_TYPE_UNKNOWN = -1,
}
#[doc = " A headset, which typically includes optics and tracking hardware, but not necessarily the device itself."]
pub use self::ovrHeadsetType_ as ovrHeadsetType;
#[repr(u32)]
#[doc = " A geographic region authorized for certain hardware and content."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceRegion_ {
    VRAPI_DEVICE_REGION_UNSPECIFIED = 0,
    VRAPI_DEVICE_REGION_JAPAN = 1,
    VRAPI_DEVICE_REGION_CHINA = 2,
}
#[doc = " A geographic region authorized for certain hardware and content."]
pub use self::ovrDeviceRegion_ as ovrDeviceRegion;
#[repr(u32)]
#[doc = " The maximum resolution and framerate supported by a video decoder."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrVideoDecoderLimit_ {
    VRAPI_VIDEO_DECODER_LIMIT_4K_30FPS = 0,
    VRAPI_VIDEO_DECODER_LIMIT_4K_60FPS = 1,
}
#[doc = " The maximum resolution and framerate supported by a video decoder."]
pub use self::ovrVideoDecoderLimit_ as ovrVideoDecoderLimit;
#[repr(u32)]
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against != VRAPI_DEVICE_EMULATION_MODE_NONE"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceEmulationMode_ {
    VRAPI_DEVICE_EMULATION_MODE_NONE = 0,
    VRAPI_DEVICE_EMULATION_MODE_GO_ON_QUEST = 1,
}
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against != VRAPI_DEVICE_EMULATION_MODE_NONE"]
pub use self::ovrDeviceEmulationMode_ as ovrDeviceEmulationMode;
#[repr(u32)]
#[doc = " System configuration properties."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemProperty_ {
    VRAPI_SYS_PROP_DEVICE_TYPE = 0,
    VRAPI_SYS_PROP_MAX_FULLSPEED_FRAMEBUFFER_SAMPLES = 1,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_WIDE = 2,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_HIGH = 3,
    #[doc = " Returns the refresh rate of the display in cycles per second."]
    VRAPI_SYS_PROP_DISPLAY_REFRESH_RATE = 4,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_WIDTH = 5,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_HEIGHT = 6,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_X = 7,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_Y = 8,
    #[doc = " Path to the external SD card. On Android-M, this path is dynamic and can"]
    #[doc = " only be determined once the SD card is mounted. Returns an empty string if"]
    #[doc = " device does not support an ext sdcard or if running Android-M and the SD card"]
    #[doc = " is not mounted."]
    VRAPI_SYS_PROP_EXT_SDCARD_PATH = 9,
    #[doc = " Path to the external SD card. On Android-M, this path is dynamic and can"]
    #[doc = " only be determined once the SD card is mounted. Returns an empty string if"]
    #[doc = " device does not support an ext sdcard or if running Android-M and the SD card"]
    #[doc = " is not mounted."]
    VRAPI_SYS_PROP_DEVICE_REGION = 10,
    #[doc = " Video decoder limit for the device."]
    VRAPI_SYS_PROP_VIDEO_DECODER_LIMIT = 11,
    #[doc = " Video decoder limit for the device."]
    VRAPI_SYS_PROP_HEADSET_TYPE = 12,
    #[doc = " Returns an ovrHandedness enum indicating left or right hand."]
    VRAPI_SYS_PROP_DOMINANT_HAND = 15,
    #[doc = " Returns the number of display refresh rates supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_DISPLAY_REFRESH_RATES = 64,
    #[doc = " Returns an array of the supported display refresh rates."]
    VRAPI_SYS_PROP_SUPPORTED_DISPLAY_REFRESH_RATES = 65,
    #[doc = " Returns the number of swapchain texture formats supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_SWAPCHAIN_FORMATS = 66,
    #[doc = " Returns an array of the supported swapchain formats."]
    #[doc = " Formats are platform specific. For GLES, this is an array of"]
    #[doc = " GL internal formats."]
    VRAPI_SYS_PROP_SUPPORTED_SWAPCHAIN_FORMATS = 67,
    #[doc = " Returns VRAPI_TRUE if Multiview rendering support is available for this system,"]
    #[doc = " otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_MULTIVIEW_AVAILABLE = 128,
    #[doc = " Returns VRAPI_TRUE if submission of SRGB Layers is supported for this system,"]
    #[doc = " otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_SRGB_LAYER_SOURCE_AVAILABLE = 129,
    #[doc = " Returns VRAPI_TRUE if on-chip foveated rendering of swapchains is supported"]
    #[doc = " for this system, otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_FOVEATION_AVAILABLE = 130,
}
#[doc = " System configuration properties."]
pub use self::ovrSystemProperty_ as ovrSystemProperty;
#[repr(u32)]
#[doc = " Configurable VrApi properties."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrProperty_ {
    VRAPI_FOVEATION_LEVEL = 15,
    VRAPI_REORIENT_HMD_ON_CONTROLLER_RECENTER = 17,
    VRAPI_LATCH_BACK_BUTTON_ENTIRE_FRAME = 18,
    VRAPI_BLOCK_REMOTE_BUTTONS_WHEN_NOT_EMULATING_HMT = 19,
    VRAPI_EAT_NATIVE_GAMEPAD_EVENTS = 20,
    VRAPI_ACTIVE_INPUT_DEVICE_ID = 24,
    VRAPI_DEVICE_EMULATION_MODE = 29,
}
#[doc = " Configurable VrApi properties."]
pub use self::ovrProperty_ as ovrProperty;
#[repr(u32)]
#[doc = " Specifies left or right handedness."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrHandedness_ {
    VRAPI_HAND_UNKNOWN = 0,
    VRAPI_HAND_LEFT = 1,
    VRAPI_HAND_RIGHT = 2,
}
#[doc = " Specifies left or right handedness."]
pub use self::ovrHandedness_ as ovrHandedness;
#[repr(u32)]
#[doc = " System status bits."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemStatus_ {
    VRAPI_SYS_STATUS_DOCKED = 0,
    VRAPI_SYS_STATUS_MOUNTED = 1,
    VRAPI_SYS_STATUS_THROTTLED = 2,
    VRAPI_SYS_STATUS_RENDER_LATENCY_MILLISECONDS = 5,
    VRAPI_SYS_STATUS_TIMEWARP_LATENCY_MILLISECONDS = 6,
    VRAPI_SYS_STATUS_SCANOUT_LATENCY_MILLISECONDS = 7,
    VRAPI_SYS_STATUS_APP_FRAMES_PER_SECOND = 8,
    VRAPI_SYS_STATUS_SCREEN_TEARS_PER_SECOND = 9,
    VRAPI_SYS_STATUS_EARLY_FRAMES_PER_SECOND = 10,
    VRAPI_SYS_STATUS_STALE_FRAMES_PER_SECOND = 11,
    VRAPI_SYS_STATUS_RECENTER_COUNT = 13,
    VRAPI_SYS_STATUS_SYSTEM_UX_ACTIVE = 14,
    VRAPI_SYS_STATUS_USER_RECENTER_COUNT = 15,
    VRAPI_SYS_STATUS_FRONT_BUFFER_PROTECTED = 128,
    VRAPI_SYS_STATUS_FRONT_BUFFER_565 = 129,
    VRAPI_SYS_STATUS_FRONT_BUFFER_SRGB = 130,
}
#[doc = " System status bits."]
pub use self::ovrSystemStatus_ as ovrSystemStatus;
#[repr(i32)]
#[doc = " Possible results of initialization."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrInitializeStatus_ {
    VRAPI_INITIALIZE_SUCCESS = 0,
    VRAPI_INITIALIZE_UNKNOWN_ERROR = -1,
    VRAPI_INITIALIZE_PERMISSIONS_ERROR = -2,
    VRAPI_INITIALIZE_ALREADY_INITIALIZED = -3,
    VRAPI_INITIALIZE_SERVICE_CONNECTION_FAILED = -4,
}
#[doc = " Possible results of initialization."]
pub use self::ovrInitializeStatus_ as ovrInitializeStatus;
#[repr(u32)]
#[doc = " Supported graphics APIs."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrGraphicsAPI_ {
    VRAPI_GRAPHICS_API_TYPE_OPENGL_ES = 65536,
    VRAPI_GRAPHICS_API_OPENGL_ES_2 = 66048,
    VRAPI_GRAPHICS_API_OPENGL_ES_3 = 66304,
    VRAPI_GRAPHICS_API_TYPE_OPENGL = 131072,
    VRAPI_GRAPHICS_API_OPENGL_COMPAT = 131328,
    VRAPI_GRAPHICS_API_OPENGL_CORE_3 = 131840,
    VRAPI_GRAPHICS_API_OPENGL_CORE_4 = 132096,
    VRAPI_GRAPHICS_API_TYPE_VULKAN = 262144,
    VRAPI_GRAPHICS_API_VULKAN_1 = 262400,
}
#[doc = " Supported graphics APIs."]
pub use self::ovrGraphicsAPI_ as ovrGraphicsAPI;
#[doc = " Configuration details specified at initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInitParms_ {
    pub Type: ovrStructureType,
    pub ProductVersion: ::std::os::raw::c_int,
    pub MajorVersion: ::std::os::raw::c_int,
    pub MinorVersion: ::std::os::raw::c_int,
    pub PatchVersion: ::std::os::raw::c_int,
    pub GraphicsAPI: ovrGraphicsAPI,
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrInitParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInitParms_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInitParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).ProductVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(ProductVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MajorVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MinorVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).PatchVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(PatchVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).GraphicsAPI as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(GraphicsAPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Java as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Configuration details specified at initialization."]
pub type ovrInitParms = ovrInitParms_;
#[repr(u32)]
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian systems."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrModeFlags_ {
    #[doc = " If set, warn and allow the app to continue at 30 FPS when throttling occurs."]
    #[doc = " If not set, display the level 2 error message which requires the user to undock."]
    VRAPI_MODE_FLAG_ALLOW_POWER_SAVE = 255,
    #[doc = " When an application moves backwards on the activity stack,"]
    #[doc = " the activity window it returns to is no longer flagged as fullscreen."]
    #[doc = " As a result, Android will also render the decor view, which wastes a"]
    #[doc = " significant amount of bandwidth."]
    #[doc = " By setting this flag, the fullscreen flag is reset on the window."]
    #[doc = " Unfortunately, this causes Android life cycle events that mess up"]
    #[doc = " several NativeActivity codebases like Stratum and UE4, so this"]
    #[doc = " flag should only be set for specific applications."]
    #[doc = " Use \"adb shell dumpsys SurfaceFlinger\" to verify"]
    #[doc = " that there is only one HWC next to the FB_TARGET."]
    VRAPI_MODE_FLAG_RESET_WINDOW_FULLSCREEN = 65280,
    #[doc = " The WindowSurface passed in is an ANativeWindow."]
    VRAPI_MODE_FLAG_NATIVE_WINDOW = 65536,
    #[doc = " Create the front buffer in TrustZone memory to allow protected DRM"]
    #[doc = " content to be rendered to the front buffer. This functionality"]
    #[doc = " requires the WindowSurface to be allocated from TimeWarp, via"]
    #[doc = " specifying the nativeWindow via VRAPI_MODE_FLAG_NATIVE_WINDOW."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_PROTECTED = 131072,
    #[doc = " Create a 16-bit 5:6:5 front buffer."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_565 = 262144,
    #[doc = " Create a front buffer using the sRGB color space."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_SRGB = 524288,
    #[doc = " If set, indicates the OpenGL ES Context was created with EGL_CONTEXT_OPENGL_NO_ERROR_KHR attribute."]
    #[doc = " The same attribute would be applied when TimeWrap creates the shared context."]
    #[doc = " More information could be found at:"]
    #[doc = " https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_create_context_no_error.txt"]
    VRAPI_MODE_FLAG_CREATE_CONTEXT_NO_ERROR = 1048576,
}
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian systems."]
pub use self::ovrModeFlags_ as ovrModeFlags;
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParms_ {
    pub Type: ovrStructureType,
    #[doc = " Combination of ovrModeFlags flags."]
    pub Flags: ::std::os::raw::c_uint,
    #[doc = " The Java VM is needed for the time warp thread to create a Java environment."]
    #[doc = " A Java environment is needed to access various system services. The thread"]
    #[doc = " that enters VR mode is responsible for attaching and detaching the Java"]
    #[doc = " environment. The Java Activity object is needed to get the windowManager,"]
    #[doc = " packageName, systemService, etc."]
    pub Java: ovrJava,
    #[doc = " Display to use for asynchronous time warp rendering."]
    #[doc = " Using EGL this is an EGLDisplay."]
    pub Display: ::std::os::raw::c_ulonglong,
    #[doc = " The window surface to use for asynchronous time warp rendering."]
    #[doc = " Using EGL this can be the EGLSurface created by the application for the ANativeWindow."]
    #[doc = " This should be the ANativeWIndow itself (requires VRAPI_MODE_FLAG_NATIVE_WINDOW)."]
    pub WindowSurface: ::std::os::raw::c_ulonglong,
    #[doc = " The resources from this context will be shared with the asynchronous time warp."]
    #[doc = " Using EGL this is an EGLContext."]
    pub ShareContext: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParms_>(),
        56usize,
        concat!("Size of: ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Java as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Java)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Display as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).WindowSurface as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(WindowSurface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).ShareContext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(ShareContext)
        )
    );
}
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
pub type ovrModeParms = ovrModeParms_;
#[doc = " Vulkan-specific mode paramaters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParmsVulkan_ {
    pub ModeParms: ovrModeParms,
    #[doc = " For Vulkan, this should be the VkQueue created on the same Device as specified"]
    #[doc = " by vrapi_CreateSystemVulkan. An internally created VkFence object will be signaled"]
    #[doc = " by the completion of commands on the queue."]
    pub SynchronizationQueue: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParmsVulkan_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParmsVulkan_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParmsVulkan_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).ModeParms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(ModeParms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).SynchronizationQueue as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(SynchronizationQueue)
        )
    );
}
#[doc = " Vulkan-specific mode paramaters."]
pub type ovrModeParmsVulkan = ovrModeParmsVulkan_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMobile {
    _unused: [u8; 0],
}
#[doc = " Full rigid body pose with first and second derivatives."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrRigidBodyPosef_ {
    pub Pose: ovrPosef,
    pub AngularVelocity: ovrVector3f,
    pub LinearVelocity: ovrVector3f,
    pub AngularAcceleration: ovrVector3f,
    pub LinearAcceleration: ovrVector3f,
    pub dead15: [::std::os::raw::c_uchar; 4usize],
    pub TimeInSeconds: f64,
    pub PredictionInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrRigidBodyPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRigidBodyPosef_>(),
        96usize,
        concat!("Size of: ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRigidBodyPosef_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).Pose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularVelocity as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearVelocity as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularAcceleration as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularAcceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearAcceleration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearAcceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).dead15 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(dead15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).TimeInSeconds as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).PredictionInSeconds as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(PredictionInSeconds)
        )
    );
}
#[doc = " Full rigid body pose with first and second derivatives."]
pub type ovrRigidBodyPosef = ovrRigidBodyPosef_;
#[repr(u32)]
#[doc = " Bit flags describing the current status of sensor tracking."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingStatus_ {
    VRAPI_TRACKING_STATUS_ORIENTATION_TRACKED = 1,
    VRAPI_TRACKING_STATUS_POSITION_TRACKED = 2,
    VRAPI_TRACKING_STATUS_ORIENTATION_VALID = 4,
    VRAPI_TRACKING_STATUS_POSITION_VALID = 8,
    VRAPI_TRACKING_STATUS_HMD_CONNECTED = 128,
}
#[doc = " Bit flags describing the current status of sensor tracking."]
pub use self::ovrTrackingStatus_ as ovrTrackingStatus;
#[doc = " Tracking state at a given absolute time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking2_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead17: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
    pub Eye: [ovrTracking2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTracking2___bindgen_ty_1 {
    pub ProjectionMatrix: ovrMatrix4f,
    pub ViewMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrTracking2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2___bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ProjectionMatrix as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ProjectionMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ViewMatrix as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ViewMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrTracking2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2_>(),
        360usize,
        concat!("Size of: ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).dead17 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(dead17)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Eye as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Eye)
        )
    );
}
#[doc = " Tracking state at a given absolute time."]
pub type ovrTracking2 = ovrTracking2_;
#[doc = " Reports the status and pose of a motion tracker."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead19: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
}
#[test]
fn bindgen_test_layout_ovrTracking_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking_>(),
        104usize,
        concat!("Size of: ", stringify!(ovrTracking_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).dead19 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(dead19)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(HeadPose)
        )
    );
}
#[doc = " Reports the status and pose of a motion tracker."]
pub type ovrTracking = ovrTracking_;
#[repr(u32)]
#[doc = " Specifies a reference frame for motion tracking data."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingTransform_ {
    VRAPI_TRACKING_TRANSFORM_IDENTITY = 0,
    VRAPI_TRACKING_TRANSFORM_CURRENT = 1,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_EYE_LEVEL = 2,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_FLOOR_LEVEL = 3,
}
#[doc = " Specifies a reference frame for motion tracking data."]
pub use self::ovrTrackingTransform_ as ovrTrackingTransform;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingSpace_ {
    VRAPI_TRACKING_SPACE_LOCAL = 0,
    VRAPI_TRACKING_SPACE_LOCAL_FLOOR = 1,
    VRAPI_TRACKING_SPACE_LOCAL_TILTED = 2,
    VRAPI_TRACKING_SPACE_STAGE = 3,
    VRAPI_TRACKING_SPACE_LOCAL_FIXED_YAW = 7,
}
pub use self::ovrTrackingSpace_ as ovrTrackingSpace;
#[repr(i32)]
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackedDeviceTypeId_ {
    VRAPI_TRACKED_DEVICE_NONE = -1,
    VRAPI_TRACKED_DEVICE_HMD = 0,
    VRAPI_TRACKED_DEVICE_HAND_LEFT = 1,
    VRAPI_TRACKED_DEVICE_HAND_RIGHT = 2,
    VRAPI_NUM_TRACKED_DEVICES = 3,
}
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
pub use self::ovrTrackedDeviceTypeId_ as ovrTrackedDeviceTypeId;
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoundaryTriggerResult_ {
    #[doc = " Closest point on the boundary surface."]
    pub ClosestPoint: ovrVector3f,
    #[doc = " Normal of the closest point on the boundary surface."]
    pub ClosestPointNormal: ovrVector3f,
    #[doc = " Distance to the closest guardian boundary surface."]
    pub ClosestDistance: f32,
    #[doc = " True if the boundary system is being triggered. Note that due to fade in/out effects this may not exactly match visibility."]
    pub IsTriggering: bool,
}
#[test]
fn bindgen_test_layout_ovrBoundaryTriggerResult_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoundaryTriggerResult_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoundaryTriggerResult_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPointNormal as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPointNormal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestDistance as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).IsTriggering as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(IsTriggering)
        )
    );
}
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
pub type ovrBoundaryTriggerResult = ovrBoundaryTriggerResult_;
#[repr(u32)]
#[doc = " A texture type, such as 2D, array, or cubemap."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureType_ {
    VRAPI_TEXTURE_TYPE_2D = 0,
    VRAPI_TEXTURE_TYPE_2D_ARRAY = 2,
    VRAPI_TEXTURE_TYPE_CUBE = 3,
    VRAPI_TEXTURE_TYPE_MAX = 4,
}
#[doc = " A texture type, such as 2D, array, or cubemap."]
pub use self::ovrTextureType_ as ovrTextureType;
#[repr(u32)]
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureFormat_ {
    VRAPI_TEXTURE_FORMAT_NONE = 0,
    VRAPI_TEXTURE_FORMAT_565 = 1,
    VRAPI_TEXTURE_FORMAT_5551 = 2,
    VRAPI_TEXTURE_FORMAT_4444 = 3,
    VRAPI_TEXTURE_FORMAT_8888 = 4,
    VRAPI_TEXTURE_FORMAT_8888_sRGB = 5,
    VRAPI_TEXTURE_FORMAT_RGBA16F = 6,
    VRAPI_TEXTURE_FORMAT_DEPTH_16 = 7,
    VRAPI_TEXTURE_FORMAT_DEPTH_24 = 8,
    VRAPI_TEXTURE_FORMAT_DEPTH_24_STENCIL_8 = 9,
    VRAPI_TEXTURE_FORMAT_RG16 = 10,
}
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
pub use self::ovrTextureFormat_ as ovrTextureFormat;
#[repr(u32)]
#[doc = " Built-in convenience swapchains."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDefaultTextureSwapChain_ {
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN = 1,
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN_LOADING_ICON = 2,
}
#[doc = " Built-in convenience swapchains."]
pub use self::ovrDefaultTextureSwapChain_ as ovrDefaultTextureSwapChain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChain {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Per-frame configuration options."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameFlags_ {
    #[doc = " Flush the warp swap pipeline so the images show up immediately."]
    #[doc = " This is expensive and should only be used when an immediate transition"]
    #[doc = " is needed like displaying black when resetting the HMD orientation."]
    VRAPI_FRAME_FLAG_FLUSH = 2,
    #[doc = " This is the final frame. Do not accept any more frames after this."]
    VRAPI_FRAME_FLAG_FINAL = 4,
    #[doc = " Don't show the volume layer when set."]
    VRAPI_FRAME_FLAG_INHIBIT_VOLUME_LAYER = 64,
}
#[doc = " Per-frame configuration options."]
pub use self::ovrFrameFlags_ as ovrFrameFlags;
#[repr(u32)]
#[doc = " Per-frame configuration options that apply to a particular layer."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerFlags_ {
    #[doc = " NOTE: On Oculus standalone devices, chromatic aberration correction is enabled"]
    #[doc = " by default."]
    #[doc = " For Gear VR devices, this must be explicitly enabled by specifying the layer"]
    #[doc = " flag as it is a quality / performance trade off."]
    VRAPI_FRAME_LAYER_FLAG_CHROMATIC_ABERRATION_CORRECTION = 2,
    #[doc = " Used for some HUDs, but generally considered bad practice."]
    VRAPI_FRAME_LAYER_FLAG_FIXED_TO_VIEW = 4,
    #[doc = " Spin the layer - for loading icons"]
    VRAPI_FRAME_LAYER_FLAG_SPIN = 8,
    #[doc = " Clip fragments outside the layer's TextureRect"]
    VRAPI_FRAME_LAYER_FLAG_CLIP_TO_TEXTURE_RECT = 16,
    #[doc = " To get gamma correct sRGB filtering of the eye textures, the textures must be"]
    #[doc = " allocated with GL_SRGB8_ALPHA8 format and the window surface must be allocated"]
    #[doc = " with these attributes:"]
    #[doc = " EGL_GL_COLORSPACE_KHR,  EGL_GL_COLORSPACE_SRGB_KHR"]
    #[doc = ""]
    #[doc = " While we can reallocate textures easily enough, we can't change the window"]
    #[doc = " colorspace without relaunching the entire application, so if you want to"]
    #[doc = " be able to toggle between gamma correct and incorrect, you must allocate"]
    #[doc = " the framebuffer as sRGB, then inhibit that processing when using normal"]
    #[doc = " textures."]
    #[doc = ""]
    #[doc = " If the texture being read isn't an sRGB texture, the conversion"]
    #[doc = " on write must be inhibited or the colors are washed out."]
    #[doc = " This is necessary for using external images on an sRGB framebuffer."]
    VRAPI_FRAME_LAYER_FLAG_INHIBIT_SRGB_FRAMEBUFFER = 256,
    #[doc = " Allow Layer to use an expensive filtering mode. Only useful for 2D layers that are high"]
    #[doc = " resolution (e.g. a remote desktop layer), typically double or more the target resolution."]
    VRAPI_FRAME_LAYER_FLAG_FILTER_EXPENSIVE = 524288,
}
#[doc = " Per-frame configuration options that apply to a particular layer."]
pub use self::ovrFrameLayerFlags_ as ovrFrameLayerFlags;
#[repr(u32)]
#[doc = " The user's eye (left or right) that can see a layer."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerEye_ {
    VRAPI_FRAME_LAYER_EYE_LEFT = 0,
    VRAPI_FRAME_LAYER_EYE_RIGHT = 1,
    VRAPI_FRAME_LAYER_EYE_MAX = 2,
}
#[doc = " The user's eye (left or right) that can see a layer."]
pub use self::ovrFrameLayerEye_ as ovrFrameLayerEye;
#[repr(u32)]
#[doc = " Selects an operation for alpha blending two images."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerBlend_ {
    VRAPI_FRAME_LAYER_BLEND_ZERO = 0,
    VRAPI_FRAME_LAYER_BLEND_ONE = 1,
    VRAPI_FRAME_LAYER_BLEND_SRC_ALPHA = 2,
    #[doc = " enum 3 used to be VRAPI_FRAME_LAYER_BLEND_DST_ALPHA."]
    #[doc = " enum 4 used to be VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_DST_ALPHA."]
    VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_SRC_ALPHA = 5,
}
#[doc = " Selects an operation for alpha blending two images."]
pub use self::ovrFrameLayerBlend_ as ovrFrameLayerBlend;
#[repr(u32)]
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrExtraLatencyMode_ {
    VRAPI_EXTRA_LATENCY_MODE_OFF = 0,
    VRAPI_EXTRA_LATENCY_MODE_ON = 1,
    VRAPI_EXTRA_LATENCY_MODE_DYNAMIC = 2,
}
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
pub use self::ovrExtraLatencyMode_ as ovrExtraLatencyMode;
#[repr(u32)]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerType_ {
    VRAPI_FRAME_LAYER_TYPE_MAX = 4,
}
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub use self::ovrFrameLayerType_ as ovrFrameLayerType;
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayerTexture_ {
    #[doc = " Because OpenGL ES does not support clampToBorder, it is the"]
    #[doc = " application's responsibility to make sure that all mip levels"]
    #[doc = " of the primary eye texture have a black border that will show"]
    #[doc = " up when time warp pushes the texture partially off screen."]
    pub ColorTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " \\deprecated The depth texture is optional for positional time warp."]
    pub DepthTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " Index to the texture from the set that should be displayed."]
    pub TextureSwapChainIndex: ::std::os::raw::c_int,
    #[doc = " Points on the screen are mapped by a distortion correction"]
    #[doc = " function into ( TanX, TanY, -1, 1 ) vectors that are transformed"]
    #[doc = " by this matrix to get ( S, T, Q, _ ) vectors that are looked"]
    #[doc = " up with texture2dproj() to get texels."]
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    #[doc = " Only texels within this range should be drawn."]
    #[doc = " This is a sub-rectangle of the [(0,0)-(1,1)] texture coordinate range."]
    pub TextureRect: ovrRectf,
    pub dead22: [::std::os::raw::c_uchar; 4usize],
    #[doc = " The tracking state for which ModelViewMatrix is correct."]
    #[doc = " It is ok to update the orientation for each eye, which"]
    #[doc = " can help minimize black edge pull-in, but the position"]
    #[doc = " must remain the same for both eyes, or the position would"]
    #[doc = " seem to judder \"backwards in time\" if a frame is dropped."]
    pub HeadPose: ovrRigidBodyPosef,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_ovrFrameLayerTexture_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayerTexture_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayerTexture_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).ColorTextureSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(ColorTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).DepthTextureSwapChain as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(DepthTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureSwapChainIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureSwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureRect as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).dead22 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(dead22)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).HeadPose as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).Pad as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(Pad)
        )
    );
}
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayerTexture = ovrFrameLayerTexture_;
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayer_ {
    #[doc = " Image used for each eye."]
    pub Textures: [ovrFrameLayerTexture; 2usize],
    #[doc = " Speed and scale of rotation when VRAPI_FRAME_LAYER_FLAG_SPIN is set in ovrFrameLayer::Flags"]
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Color scale for this layer (including alpha)"]
    pub ColorScale: f32,
    pub dead25: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layer blend function."]
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " Combination of ovrFrameLayerFlags flags."]
    pub Flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrFrameLayer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayer_>(),
        448usize,
        concat!("Size of: ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Textures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinSpeed as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinScale as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).ColorScale as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).dead25 as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(dead25)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SrcBlend as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).DstBlend as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayer = ovrFrameLayer_;
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPerformanceParms_ {
    #[doc = " These are fixed clock levels in the range [0, 3]."]
    pub CpuLevel: ::std::os::raw::c_int,
    pub GpuLevel: ::std::os::raw::c_int,
    #[doc = " These threads will get SCHED_FIFO."]
    pub MainThreadTid: ::std::os::raw::c_int,
    pub RenderThreadTid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrPerformanceParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPerformanceParms_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPerformanceParms_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).CpuLevel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(CpuLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).GpuLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(GpuLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).MainThreadTid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(MainThreadTid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).RenderThreadTid as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(RenderThreadTid)
        )
    );
}
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrPerformanceParms = ovrPerformanceParms_;
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameParms_ {
    pub Type: ovrStructureType,
    pub dead29: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layers composited in the time warp."]
    pub Layers: [ovrFrameLayer; 4usize],
    pub LayerCount: ::std::os::raw::c_int,
    #[doc = " Combination of ovrFrameFlags flags."]
    pub Flags: ::std::os::raw::c_int,
    #[doc = " Application controlled frame index that uniquely identifies this particular frame."]
    #[doc = " This must be the same frame index that was passed to vrapi_GetPredictedDisplayTime()"]
    #[doc = " when synthesis of this frame started."]
    pub FrameIndex: ::std::os::raw::c_longlong,
    #[doc = " WarpSwap will not return until at least this many V-syncs have"]
    #[doc = " passed since the previous WarpSwap returned."]
    #[doc = " Setting to 2 will reduce power consumption and may make animation"]
    #[doc = " more regular for applications that can't hold full frame rate."]
    pub SwapInterval: ::std::os::raw::c_int,
    #[doc = " Latency Mode."]
    pub ExtraLatencyMode: ovrExtraLatencyMode,
    #[doc = " \\unused parameter."]
    pub Reserved: ovrMatrix4f,
    #[doc = " \\unused parameter."]
    pub Reserved1: *mut ::std::os::raw::c_void,
    #[doc = " CPU/GPU performance parameters."]
    pub PerformanceParms: ovrPerformanceParms,
    #[doc = " For handling HMD events and power level state changes."]
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrFrameParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameParms_>(),
        1936usize,
        concat!("Size of: ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).dead29 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(dead29)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Layers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).LayerCount as *const _ as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Flags as *const _ as usize },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).FrameIndex as *const _ as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).SwapInterval as *const _ as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).ExtraLatencyMode as *const _ as usize },
        1820usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(ExtraLatencyMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved as *const _ as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved1 as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).PerformanceParms as *const _ as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(PerformanceParms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Java as *const _ as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameParms = ovrFrameParms_;
#[repr(u32)]
#[doc = " A layer type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrLayerType2_ {
    VRAPI_LAYER_TYPE_PROJECTION2 = 1,
    VRAPI_LAYER_TYPE_CYLINDER2 = 3,
    VRAPI_LAYER_TYPE_CUBE2 = 4,
    VRAPI_LAYER_TYPE_EQUIRECT2 = 5,
    VRAPI_LAYER_TYPE_LOADING_ICON2 = 6,
    VRAPI_LAYER_TYPE_FISHEYE2 = 7,
}
#[doc = " A layer type."]
pub use self::ovrLayerType2_ as ovrLayerType2;
#[doc = " Properties shared by any type of layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerHeader2_ {
    pub Type: ovrLayerType2,
    pub Flags: u32,
    pub ColorScale: ovrVector4f,
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " \\unused parameter."]
    pub Reserved: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ovrLayerHeader2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerHeader2_>(),
        40usize,
        concat!("Size of: ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerHeader2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).ColorScale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).SrcBlend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).DstBlend as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Properties shared by any type of layer."]
pub type ovrLayerHeader2 = ovrLayerHeader2_;
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerProjection2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_PROJECTION2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerProjection2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerProjection2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerProjection2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).ColorSwapChain
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).SwapChainIndex
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2_>(),
        328usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
pub type ovrLayerProjection2 = ovrLayerProjection2_;
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " comes from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCylinder2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CYLINDER2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerCylinder2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCylinder2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2_>(),
        456usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " comes from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerCylinder2 = ovrLayerCylinder2_;
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCube2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CUBE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Offset: ovrVector3f,
    pub Textures: [ovrLayerCube2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCube2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a cube target (VRAPI_TEXTURE_TYPE_CUBE)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerCube2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2___bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCube2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2_>(),
        248usize,
        concat!("Size of: ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2_>())).TexCoordsFromTanAngles as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Offset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Textures as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
pub type ovrLayerCube2 = ovrLayerCube2_;
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a direction-to-equirect"]
#[doc = " mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " come from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEquirect2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_EQUIRECT2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Textures: [ovrLayerEquirect2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerEquirect2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2_>(),
        392usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Textures as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a direction-to-equirect"]
#[doc = " mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " come from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerEquirect2 = ovrLayerEquirect2_;
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerLoadingIcon2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_LOADING_ICON2."]
    pub Header: ovrLayerHeader2,
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Only monoscopic texture supported for spinning layer."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerLoadingIcon2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerLoadingIcon2_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerLoadingIcon2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinSpeed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinScale as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).ColorSwapChain as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SwapChainIndex as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
pub type ovrLayerLoadingIcon2 = ovrLayerLoadingIcon2_;
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for stereo."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerFishEye2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_FISHEYE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerFishEye2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerFishEye2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub LensFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    pub TextureMatrix: ovrMatrix4f,
    pub Distortion: ovrVector4f,
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).LensFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(LensFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).Distortion as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(Distortion)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for stereo."]
#[doc = ""]
pub type ovrLayerFishEye2 = ovrLayerFishEye2_;
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrLayer_Union2_ {
    pub Header: ovrLayerHeader2,
    pub Projection: ovrLayerProjection2,
    pub Cylinder: ovrLayerCylinder2,
    pub Cube: ovrLayerCube2,
    pub Equirect: ovrLayerEquirect2,
    pub LoadingIcon: ovrLayerLoadingIcon2,
    pub FishEye: ovrLayerFishEye2,
    _bindgen_union_align: [u64; 61usize],
}
#[test]
fn bindgen_test_layout_ovrLayer_Union2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayer_Union2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayer_Union2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Projection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cylinder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cube as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cube)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Equirect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Equirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).LoadingIcon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(LoadingIcon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).FishEye as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(FishEye)
        )
    );
}
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
pub type ovrLayer_Union2 = ovrLayer_Union2_;
#[doc = " Parameters for frame submission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSubmitFrameDescription2_ {
    pub Flags: u32,
    pub SwapInterval: u32,
    pub FrameIndex: u64,
    pub DisplayTime: f64,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
    pub LayerCount: u32,
    pub Layers: *const *const ovrLayerHeader2,
}
#[test]
fn bindgen_test_layout_ovrSubmitFrameDescription2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSubmitFrameDescription2_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSubmitFrameDescription2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).SwapInterval as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).FrameIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).DisplayTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(DisplayTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Pad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).LayerCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Layers as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Layers)
        )
    );
}
#[doc = " Parameters for frame submission."]
pub type ovrSubmitFrameDescription2 = ovrSubmitFrameDescription2_;
#[repr(u32)]
#[doc = " Identifies a VR-related application thread."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrPerfThreadType_ {
    VRAPI_PERF_THREAD_TYPE_MAIN = 0,
    VRAPI_PERF_THREAD_TYPE_RENDERER = 1,
}
#[doc = " Identifies a VR-related application thread."]
pub use self::ovrPerfThreadType_ as ovrPerfThreadType;
extern "C" {
    #[doc = " Returns the version + compile time stamp as a string."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns global, absolute high-resolution time in seconds. This is the same value"]
    #[doc = " as used in sensor messages and on Android also the same as Java's system.nanoTime(),"]
    #[doc = " which is what the Choreographer V-sync timestamp is based on."]
    #[doc = " \\warning Do not use this time as a seed for simulations, animations or other logic."]
    #[doc = " An animation, for instance, should not be updated based on the \"real time\" the"]
    #[doc = " animation code is executed. Instead, an animation should be updated based on the"]
    #[doc = " time it will be displayed. Using the \"real time\" will introduce intra-frame motion"]
    #[doc = " judder when the code is not executed at a consistent point in time every frame."]
    #[doc = " In other words, for simulations, animations and other logic use the time returned"]
    #[doc = " by vrapi_GetPredictedDisplayTime()."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetTimeInSeconds() -> f64;
}
extern "C" {
    #[doc = " Initializes the API for application use."]
    #[doc = " This is lightweight and does not create any threads."]
    #[doc = " This is typically called from onCreate() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    #[doc = " Returns a non-zero value from ovrInitializeStatus on error."]
    pub fn vrapi_Initialize(initParms: *const ovrInitParms) -> ovrInitializeStatus;
}
extern "C" {
    #[doc = " Shuts down the API on application exit."]
    #[doc = " This is typically called from onDestroy() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    pub fn vrapi_Shutdown();
}
extern "C" {
    #[doc = " Returns a VrApi property."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_SetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vrapi_SetPropertyFloat(java: *const ovrJava, propType: ovrProperty, floatVal: f32);
}
extern "C" {
    #[doc = " Returns false if the property cannot be read."]
    pub fn vrapi_GetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns a system property. These are constants for a particular device."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemPropertyInt(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyFloat(java: *const ovrJava, propType: ovrSystemProperty) -> f32;
}
extern "C" {
    #[doc = " Returns the number of elements written to values array."]
    pub fn vrapi_GetSystemPropertyFloatArray(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut f32,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyInt64Array(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut i64,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The return memory is guaranteed to be valid until the next call to vrapi_GetSystemPropertyString."]
    pub fn vrapi_GetSystemPropertyString(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a system status. These are variables that may change at run-time."]
    #[doc = " This function can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemStatusInt(
        java: *const ovrJava,
        statusType: ovrSystemStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemStatusFloat(java: *const ovrJava, statusType: ovrSystemStatus) -> f32;
}
extern "C" {
    #[doc = " Starts up the time warp, V-sync tracking, sensor reading, clock locking,"]
    #[doc = " thread scheduling, and sets video options. The parms are copied, and are"]
    #[doc = " not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This should be called after vrapi_Initialize(), when the app is both"]
    #[doc = " resumed and has a valid window surface (ANativeWindow)."]
    #[doc = ""]
    #[doc = " On Android, an application cannot just allocate a new window surface"]
    #[doc = " and render to it. Android allocates and manages the window surface and"]
    #[doc = " (after the fact) notifies the application of the state of affairs through"]
    #[doc = " life cycle events (surfaceCreated / surfaceChanged / surfaceDestroyed)."]
    #[doc = " The application (or 3rd party engine) typically handles these events."]
    #[doc = " Since the VrApi cannot just allocate a new window surface, and the VrApi"]
    #[doc = " does not handle the life cycle events, the VrApi somehow has to take over"]
    #[doc = " ownership of the Android surface from the application. To allow this, the"]
    #[doc = " application can explicitly pass the EGLDisplay, EGLContext and EGLSurface"]
    #[doc = " or ANativeWindow to vrapi_EnterVrMode(). The EGLDisplay and EGLContext are"]
    #[doc = " used to create a shared context used by the background time warp thread."]
    #[doc = ""]
    #[doc = " If, however, the application does not explicitly pass in these objects, then"]
    #[doc = " vrapi_EnterVrMode() *must* be called from a thread with an OpenGL ES context"]
    #[doc = " current on the Android window surface. The context of the calling thread is"]
    #[doc = " then used to match the version and config for the context used by the background"]
    #[doc = " time warp thread. The time warp will also hijack the Android window surface"]
    #[doc = " from the context that is current on the calling thread. On return, the context"]
    #[doc = " from the calling thread will be current on an invisible pbuffer, because the"]
    #[doc = " time warp takes ownership of the Android window surface. Note that this requires"]
    #[doc = " the config used by the calling thread to have an EGL_SURFACE_TYPE with EGL_PBUFFER_BIT."]
    #[doc = ""]
    #[doc = " New applications must always explicitly pass in the EGLDisplay, EGLContext"]
    #[doc = " and ANativeWindow, otherwise vrapi_EnterVrMode will fail."]
    #[doc = ""]
    #[doc = " This function will return NULL when entering VR mode failed because the ANativeWindow"]
    #[doc = " was not valid. If the ANativeWindow's buffer queue is abandoned"]
    #[doc = " (\"BufferQueueProducer: BufferQueue has been abandoned\"), then the app can wait for a"]
    #[doc = " new ANativeWindow (through SurfaceCreated). If another API is already connected to"]
    #[doc = " the ANativeWindow (\"BufferQueueProducer: already connected\"), then the app has to first"]
    #[doc = " disconnect whatever is connected to the ANativeWindow (typically an EGLSurface)."]
    pub fn vrapi_EnterVrMode(parms: *const ovrModeParms) -> *mut ovrMobile;
}
extern "C" {
    #[doc = " Shut everything down for window destruction or when the activity is paused."]
    #[doc = " The ovrMobile object is freed by this function."]
    #[doc = ""]
    #[doc = " Must be called from the same thread that called vrapi_EnterVrMode(). If the"]
    #[doc = " application did not explicitly pass in the Android window surface, then this"]
    #[doc = " thread *must* have the same OpenGL ES context that was current on the Android"]
    #[doc = " window surface before calling vrapi_EnterVrMode(). By calling this function,"]
    #[doc = " the time warp gives up ownership of the Android window surface, and on return,"]
    #[doc = " the context from the calling thread will be current again on the Android window"]
    #[doc = " surface."]
    pub fn vrapi_LeaveVrMode(ovr: *mut ovrMobile);
}
extern "C" {
    #[doc = " Returns a predicted absolute system time in seconds at which the next set"]
    #[doc = " of eye images will be displayed."]
    #[doc = ""]
    #[doc = " The predicted time is the middle of the time period during which the new"]
    #[doc = " eye images will be displayed. The number of frames predicted ahead depends"]
    #[doc = " on the pipeline depth of the engine and the minumum number of V-syncs in"]
    #[doc = " between eye image rendering. The better the prediction, the less black will"]
    #[doc = " be pulled in at the edges by the time warp."]
    #[doc = ""]
    #[doc = " The frameIndex is an application controlled number that uniquely identifies"]
    #[doc = " the new set of eye images for which synthesis is about to start. This same"]
    #[doc = " frameIndex must be passed to vrapi_SubmitFrame() when the new eye images are"]
    #[doc = " submitted to the time warp. The frameIndex is expected to be incremented"]
    #[doc = " once every frame before calling this function."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedDisplayTime(
        ovr: *mut ovrMobile,
        frameIndex: ::std::os::raw::c_longlong,
    ) -> f64;
}
extern "C" {
    #[doc = " Returns the predicted sensor state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedTracking2(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking2;
}
extern "C" {
    pub fn vrapi_GetPredictedTracking(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking;
}
extern "C" {
    pub fn vrapi_RecenterPose(ovr: *mut ovrMobile);
}
extern "C" {
    pub fn vrapi_GetTrackingTransform(
        ovr: *mut ovrMobile,
        whichTransform: ovrTrackingTransform,
    ) -> ovrPosef;
}
extern "C" {
    pub fn vrapi_SetTrackingTransform(ovr: *mut ovrMobile, pose: ovrPosef);
}
extern "C" {
    #[doc = " Returns the current tracking space"]
    pub fn vrapi_GetTrackingSpace(ovr: *mut ovrMobile) -> ovrTrackingSpace;
}
extern "C" {
    #[doc = " Set the tracking space. There are currently two options:"]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL (default)"]
    #[doc = "         The local tracking space's origin is at the nominal head position"]
    #[doc = "         with +y up, and -z forward. This space is volatile and will change"]
    #[doc = "         when system recentering occurs."]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL_FLOOR"]
    #[doc = "         The local floor tracking space is the same as the local tracking"]
    #[doc = "         space, except its origin is translated down to the floor. The local"]
    #[doc = "         floor space differs from the local space only in its y translation."]
    #[doc = "         This space is volatile and will change when system recentering occurs."]
    pub fn vrapi_SetTrackingSpace(ovr: *mut ovrMobile, whichSpace: ovrTrackingSpace) -> ovrResult;
}
extern "C" {
    #[doc = " Returns pose of the requested space relative to the current space."]
    #[doc = " The returned value is not affected by the current tracking transform."]
    pub fn vrapi_LocateTrackingSpace(ovr: *mut ovrMobile, target: ovrTrackingSpace) -> ovrPosef;
}
extern "C" {
    #[doc = " Get the geometry of the Guardian System as a list of points that define the outer boundary space."]
    #[doc = " You can choose to get just the number of points by passing in a null value for points or"]
    #[doc = " by passing in a pointsCountInput size of 0.  Otherwise pointsCountInput will be used to fetch"]
    #[doc = " as many points as possible from the Guardian points data.  If the input size exceeds the"]
    #[doc = " number of points that are currently stored off we only copy up to the number of points that we"]
    #[doc = " have and pointsCountOutput will return the number of copied points"]
    pub fn vrapi_GetBoundaryGeometry(
        ovr: *mut ovrMobile,
        pointsCountInput: u32,
        pointsCountOutput: *mut u32,
        points: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the dimension of the Oriented Bounding box for the Guardian System.  This is the largest"]
    #[doc = " fit rectangle within the Guardian System boundary geometry. The pose value contains the forward facing"]
    #[doc = " direction as well as the translation for the oriented box.  The scale return value returns a"]
    #[doc = " scalar value for the width, height, and depth of the box.  These values are half the actual size"]
    #[doc = " as they are scalars and in meters.\""]
    pub fn vrapi_GetBoundaryOrientedBoundingBox(
        ovr: *mut ovrMobile,
        pose: *mut ovrPosef,
        scale: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of a 3D point against the Guardian System Boundary and returns whether or not a"]
    #[doc = " given point is inside or outside of the boundary.  If a more detailed set of boundary"]
    #[doc = " trigger information is requested a ovrBoundaryTriggerResult may be passed in.  However null may"]
    #[doc = " also be passed in to just return whether a point is inside the boundary or not."]
    pub fn vrapi_TestPointIsInBoundary(
        ovr: *mut ovrMobile,
        point: ovrVector3f,
        pointInsideBoundary: *mut bool,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of position tracked devices (e.g. HMD and/or Controllers) against the"]
    #[doc = " Guardian System boundary. This function returns an ovrGuardianTriggerResult which contains information"]
    #[doc = " such as distance and closest point based on collision/proximity test"]
    pub fn vrapi_GetBoundaryTriggerState(
        ovr: *mut ovrMobile,
        deviceId: ovrTrackedDeviceTypeId,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Used to force Guardian System mesh visibility to true.  Forcing to false will set the Guardian"]
    #[doc = " System back to normal operation."]
    pub fn vrapi_RequestBoundaryVisible(ovr: *mut ovrMobile, visible: bool) -> ovrResult;
}
extern "C" {
    #[doc = " Used to access whether or not the Guardian System is visible or not"]
    pub fn vrapi_GetBoundaryVisible(ovr: *mut ovrMobile, visible: *mut bool) -> ovrResult;
}
extern "C" {
    #[doc = " Create a texture swap chain that can be passed to vrapi_SubmitFrame."]
    #[doc = " Must be called from a thread with a valid OpenGL ES context current."]
    #[doc = ""]
    #[doc = " 'bufferCount' used to be a bool that selected either a single texture index"]
    #[doc = " or a triple buffered index, but the new entry point vrapi_CreateTextureSwapChain2,"]
    #[doc = " allows up to 16 buffers to be allocated, which is useful for maintaining a"]
    #[doc = " deep video buffer queue to get better frame timing."]
    #[doc = ""]
    #[doc = " 'format' used to be an ovrTextureFormat but has been expanded to accept"]
    #[doc = " platform specific format types. For GLES, this is the internal format."]
    #[doc = " If an unsupported format is provided, swapchain creation will fail."]
    #[doc = ""]
    #[doc = " SwapChain creation failures result in a return value of 'nullptr'."]
    pub fn vrapi_CreateTextureSwapChain3(
        type_: ovrTextureType,
        format: i64,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain2(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        buffered: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Create an Android SurfaceTexture based texture swap chain suitable for use with vrapi_SubmitFrame."]
    #[doc = " Updating of the SurfaceTexture is handled through normal Android platform specific mechanisms"]
    #[doc = " from within the Compositor. A reference to the Android Surface object associated with the SurfaceTexture"]
    #[doc = " may be obtained by calling vrapi_GetTextureSwapChainAndroidSurface."]
    #[doc = ""]
    #[doc = " An optional width and height (ie width and height do not equal zero) may be provided in order to set"]
    #[doc = " the default size of the image buffers."]
    #[doc = " Note that the image producer may override the buffer size, in which case the default values provided"]
    #[doc = " here will not be used (ie both video decompression or camera preview override the size automatically)."]
    #[doc = ""]
    #[doc = " If isProtected is true, the surface swapchain will be created as a protected surface, ie for supporting"]
    #[doc = " secure video playback."]
    #[doc = ""]
    #[doc = " NOTE: These paths are not currently supported under Vulkan."]
    pub fn vrapi_CreateAndroidSurfaceSwapChain(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateAndroidSurfaceSwapChain2(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isProtected: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Destroy the given texture swap chain."]
    #[doc = " Must be called from a thread with the same OpenGL ES context current when vrapi_CreateTextureSwapChain was called."]
    pub fn vrapi_DestroyTextureSwapChain(chain: *mut ovrTextureSwapChain);
}
extern "C" {
    #[doc = " Returns the number of textures in the swap chain."]
    pub fn vrapi_GetTextureSwapChainLength(
        chain: *mut ovrTextureSwapChain,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the OpenGL name of the texture at the given index."]
    pub fn vrapi_GetTextureSwapChainHandle(
        chain: *mut ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the Android Surface object associated with the swap chain."]
    pub fn vrapi_GetTextureSwapChainAndroidSurface(chain: *mut ovrTextureSwapChain) -> jobject;
}
extern "C" {
    #[doc = " Accepts new eye images plus poses that will be used for future warps."]
    #[doc = " The parms are copied, and are not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This will block until the textures from the previous vrapi_SubmitFrame() have been"]
    #[doc = " consumed by the background thread, to allow one frame of overlap for maximum"]
    #[doc = " GPU utilization, while preventing multiple frames from piling up variable latency."]
    #[doc = ""]
    #[doc = " This will block until at least SwapInterval vsyncs have passed since the last"]
    #[doc = " call to vrapi_SubmitFrame() to prevent applications with simple scenes from"]
    #[doc = " generating completely wasted frames."]
    #[doc = ""]
    #[doc = " IMPORTANT: any dynamic textures that are passed to vrapi_SubmitFrame() must be"]
    #[doc = " triple buffered to avoid flickering and performance problems."]
    #[doc = ""]
    #[doc = " The VrApi allows for one frame of overlap which is essential on tiled mobile GPUs."]
    #[doc = " Because there is one frame of overlap, the eye images have typically not completed"]
    #[doc = " rendering by the time they are submitted to vrapi_SubmitFrame(). To allow the time"]
    #[doc = " warp to check whether the eye images have completed rendering, vrapi_SubmitFrame()"]
    #[doc = " adds a sync object to the current context. Therefore, vrapi_SubmitFrame() *must*"]
    #[doc = " be called from a thread with an OpenGL ES context whose completion ensures that"]
    #[doc = " frame rendering is complete. Generally this is the thread and context that was used"]
    #[doc = " for the rendering."]
    pub fn vrapi_SubmitFrame(ovr: *mut ovrMobile, parms: *const ovrFrameParms);
}
extern "C" {
    #[doc = " vrapi_SubmitFrame2 takes a frameDescription describing per-frame information such as:"]
    #[doc = " a flexible list of layers which should be drawn this frame and a frame index."]
    pub fn vrapi_SubmitFrame2(
        ovr: *mut ovrMobile,
        frameDescription: *const ovrSubmitFrameDescription2,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Set the CPU and GPU performance levels."]
    #[doc = ""]
    #[doc = " Increasing the levels increases performance at the cost of higher power consumption"]
    #[doc = " which likely leads to a greater chance of overheating."]
    #[doc = ""]
    #[doc = " Levels will be clamped to the expected range. Default clock levels are cpuLevel = 2, gpuLevel = 2."]
    pub fn vrapi_SetClockLevels(ovr: *mut ovrMobile, cpuLevel: i32, gpuLevel: i32) -> ovrResult;
}
extern "C" {
    #[doc = " Specify which app threads should be given higher scheduling priority."]
    pub fn vrapi_SetPerfThread(
        ovr: *mut ovrMobile,
        type_: ovrPerfThreadType,
        threadId: u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " If VRAPI_EXTRA_LATENCY_MODE_ON specified, adds an extra frame of latency for full GPU utilization."]
    #[doc = " Default is VRAPI_EXTRA_LATENCY_MODE_OFF."]
    #[doc = ""]
    #[doc = " The latency mode specified will be applied on the next call to vrapi_SubmitFrame(2)."]
    pub fn vrapi_SetExtraLatencyMode(ovr: *mut ovrMobile, mode: ovrExtraLatencyMode) -> ovrResult;
}
extern "C" {
    #[doc = " Set the Display Refresh Rate."]
    #[doc = " Returns ovrSuccess or an ovrError code."]
    #[doc = " Returns 'ovrError_InvalidParameter' if requested refresh rate is not supported by the device."]
    #[doc = " Returns 'ovrError_InvalidOperation' if the display refresh rate request was not allowed (such as when the device is in low power mode)."]
    pub fn vrapi_SetDisplayRefreshRate(ovr: *mut ovrMobile, refreshRate: f32) -> ovrResult;
}
#[repr(u32)]
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are never"]
#[doc = " reported to applications."]
#[doc = " ovrButton_Back button has system-level handling for long presses, but application-level handling for"]
#[doc = " short-presses. Since a short-press is determined by the time interval between down and up events, the"]
#[doc = " ovrButton_Back flag is only set when the back button comes up in less than the short-press time (0.25"]
#[doc = " seconds). The ovrButton_Back flag always signals a short press and will only remain set for a single frame."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrButton_ {
    ovrButton_A = 1,
    ovrButton_B = 2,
    ovrButton_RThumb = 4,
    ovrButton_RShoulder = 8,
    ovrButton_X = 256,
    ovrButton_Y = 512,
    ovrButton_LThumb = 1024,
    ovrButton_LShoulder = 2048,
    ovrButton_Up = 65536,
    ovrButton_Down = 131072,
    ovrButton_Left = 262144,
    ovrButton_Right = 524288,
    ovrButton_Enter = 1048576,
    ovrButton_Back = 2097152,
    ovrButton_GripTrigger = 67108864,
    ovrButton_Trigger = 536870912,
    ovrButton_Joystick = 2147483648,
    ovrButton_EnumSize = 2147483647,
}
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are never"]
#[doc = " reported to applications."]
#[doc = " ovrButton_Back button has system-level handling for long presses, but application-level handling for"]
#[doc = " short-presses. Since a short-press is determined by the time interval between down and up events, the"]
#[doc = " ovrButton_Back flag is only set when the back button comes up in less than the short-press time (0.25"]
#[doc = " seconds). The ovrButton_Back flag always signals a short press and will only remain set for a single frame."]
pub use self::ovrButton_ as ovrButton;
#[repr(u32)]
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTouch_ {
    ovrTouch_A = 1,
    ovrTouch_B = 2,
    ovrTouch_X = 4,
    ovrTouch_Y = 8,
    ovrTouch_TrackPad = 16,
    ovrTouch_Joystick = 32,
    ovrTouch_IndexTrigger = 64,
    ovrTouch_ThumbUp = 256,
    ovrTouch_IndexPointing = 512,
    ovrTouch_BaseState = 768,
    ovrTouch_LThumb = 1024,
    ovrTouch_RThumb = 2048,
    ovrTouch_EnumSize = 2049,
}
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
pub use self::ovrTouch_ as ovrTouch;
#[repr(u32)]
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerType_ {
    ovrControllerType_None = 0,
    ovrControllerType_Reserved0 = 1,
    ovrControllerType_Reserved1 = 2,
    ovrControllerType_TrackedRemote = 4,
    ovrControllerType_Headset = 8,
    ovrControllerType_Gamepad = 16,
    ovrControllerType_EnumSize = 2147483647,
}
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
pub use self::ovrControllerType_ as ovrControllerType;
pub type ovrDeviceID = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceIdType_ {
    ovrDeviceIdType_Invalid = 2147483647,
}
pub use self::ovrDeviceIdType_ as ovrDeviceIdType;
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputCapabilityHeader_ {
    pub Type: ovrControllerType,
    #[doc = " A unique ID for the input device"]
    pub DeviceID: ovrDeviceID,
}
#[test]
fn bindgen_test_layout_ovrInputCapabilityHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputCapabilityHeader_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputCapabilityHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).DeviceID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(DeviceID)
        )
    );
}
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputCapabilityHeader = ovrInputCapabilityHeader_;
#[repr(u32)]
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerCapabilities_ {
    ovrControllerCaps_HasOrientationTracking = 1,
    ovrControllerCaps_HasPositionTracking = 2,
    ovrControllerCaps_LeftHand = 4,
    ovrControllerCaps_RightHand = 8,
    ovrControllerCaps_ModelOculusGo = 16,
    ovrControllerCaps_HasAnalogIndexTrigger = 64,
    ovrControllerCaps_HasAnalogGripTrigger = 128,
    ovrControllerCaps_HasSimpleHapticVibration = 512,
    ovrControllerCaps_HasBufferedHapticVibration = 1024,
    ovrControllerCaps_ModelGearVR = 2048,
    ovrControllerCaps_HasTrackpad = 4096,
    ovrControllerCaps_HasJoystick = 8192,
    ovrControllerCaps_ModelOculusTouch = 16384,
    ovrControllerCaps_EnumSize = 2147483647,
}
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
pub use self::ovrControllerCapabilities_ as ovrControllerCapabilties;
#[doc = " Details about the Oculus Remote input device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputTrackedRemoteCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    #[doc = " Maximum coordinates of the Trackpad, bottom right exclusive"]
    #[doc = " For a 300x200 Trackpad, return 299x199"]
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    #[doc = " Size of the Trackpad in mm (millimeters)"]
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
    #[doc = " added in API version 1.1.13.0"]
    #[doc = " Maximum submittable samples for the haptics buffer"]
    pub HapticSamplesMax: u32,
    #[doc = " length in milliseconds of a sample in the haptics buffer."]
    pub HapticSampleDurationMS: u32,
    #[doc = " added in API version 1.1.15.0"]
    pub TouchCapabilities: u32,
    pub Reserved4: u32,
    pub Reserved5: u32,
}
#[test]
fn bindgen_test_layout_ovrInputTrackedRemoteCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputTrackedRemoteCapabilities_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInputTrackedRemoteCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputTrackedRemoteCapabilities_>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ovrInputTrackedRemoteCapabilities_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ButtonCapabilities
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxX as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxY as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSamplesMax
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSamplesMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSampleDurationMS
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSampleDurationMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TouchCapabilities
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TouchCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved4 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved5 as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved5)
        )
    );
}
#[doc = " Details about the Oculus Remote input device."]
pub type ovrInputTrackedRemoteCapabilities = ovrInputTrackedRemoteCapabilities_;
#[doc = " Capabilities for the Head Mounted Tracking device (i.e. the headset)."]
#[doc = " Note that the GearVR headset firmware always sends relative coordinates"]
#[doc = " with the initial touch position offset by (1280,720). There is no way"]
#[doc = " to get purely raw coordinates from the headset. In addition, these"]
#[doc = " coordinates get adjusted for acceleration resulting in a slow movement"]
#[doc = " from one edge to the other the having a coordinate range of about 300"]
#[doc = " units, while a fast movement from edge to edge may result in a range"]
#[doc = " close to 900 units."]
#[doc = " This means the headset touchpad needs to be handled differently than"]
#[doc = " the GearVR Controller touchpad."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputHeadsetCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    #[doc = " Maximum coordinates of the Trackpad, bottom right exclusive"]
    #[doc = " For a 300x200 Trackpad, return 299x199"]
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    #[doc = " Size of the Trackpad in mm (millimeters)"]
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
}
#[test]
fn bindgen_test_layout_ovrInputHeadsetCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputHeadsetCapabilities_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrInputHeadsetCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputHeadsetCapabilities_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputHeadsetCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).ButtonCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadMaxX as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadMaxX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadMaxY as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadMaxY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadSizeY)
        )
    );
}
#[doc = " Capabilities for the Head Mounted Tracking device (i.e. the headset)."]
#[doc = " Note that the GearVR headset firmware always sends relative coordinates"]
#[doc = " with the initial touch position offset by (1280,720). There is no way"]
#[doc = " to get purely raw coordinates from the headset. In addition, these"]
#[doc = " coordinates get adjusted for acceleration resulting in a slow movement"]
#[doc = " from one edge to the other the having a coordinate range of about 300"]
#[doc = " units, while a fast movement from edge to edge may result in a range"]
#[doc = " close to 900 units."]
#[doc = " This means the headset touchpad needs to be handled differently than"]
#[doc = " the GearVR Controller touchpad."]
pub type ovrInputHeadsetCapabilities = ovrInputHeadsetCapabilities_;
#[doc = " Capabilities for an XBox style game pad"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputGamepadCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputGamepadCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputGamepadCapabilities_>(),
        176usize,
        concat!("Size of: ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputGamepadCapabilities_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ButtonCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Capabilities for an XBox style game pad"]
pub type ovrInputGamepadCapabilities = ovrInputGamepadCapabilities_;
#[doc = " The buffer data for playing haptics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticBuffer_ {
    #[doc = " Start time of the buffer"]
    pub BufferTime: f64,
    #[doc = " Number of samples in the buffer;"]
    pub NumSamples: u32,
    pub Terminated: bool,
    pub HapticBuffer: *mut u8,
}
#[test]
fn bindgen_test_layout_ovrHapticBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticBuffer_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).BufferTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(BufferTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).NumSamples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(NumSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).Terminated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(Terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).HapticBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(HapticBuffer)
        )
    );
}
#[doc = " The buffer data for playing haptics"]
pub type ovrHapticBuffer = ovrHapticBuffer_;
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateHeader_ {
    #[doc = " Type type of controller"]
    pub ControllerType: ovrControllerType,
    #[doc = " System time when the controller state was last updated."]
    pub TimeInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHeader_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHeader_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).ControllerType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(ControllerType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).TimeInSeconds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
}
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputStateHeader = ovrInputStateHeader_;
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateTrackedRemote_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    #[doc = " Finger contact status for trackpad"]
    #[doc = " true = finger is on trackpad, false = finger is off trackpad"]
    pub TrackpadStatus: u32,
    #[doc = " X and Y coordinates of the Trackpad"]
    pub TrackpadPosition: ovrVector2f,
    #[doc = " The percentage of max battery charge remaining."]
    pub BatteryPercentRemaining: u8,
    #[doc = " Increments every time the remote is recentered. If this changes, the application may need"]
    #[doc = " to adjust its arm model accordingly."]
    pub RecenterCount: u8,
    #[doc = " Reserved for future use."]
    pub Reserved: u16,
    #[doc = " added in API version 1.1.13.0"]
    pub IndexTrigger: f32,
    pub GripTrigger: f32,
    #[doc = " added in API version 1.1.15.0"]
    pub Touches: u32,
    pub Reserved5a: u32,
    pub Joystick: ovrVector2f,
    pub JoystickNoDeadZone: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateTrackedRemote_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateTrackedRemote_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateTrackedRemote_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Buttons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadStatus as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadPosition as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).BatteryPercentRemaining
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(BatteryPercentRemaining)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).RecenterCount as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(RecenterCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).IndexTrigger as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(IndexTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).GripTrigger as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(GripTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Touches as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Touches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved5a as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved5a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Joystick as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Joystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).JoystickNoDeadZone as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(JoystickNoDeadZone)
        )
    );
}
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
pub type ovrInputStateTrackedRemote = ovrInputStateTrackedRemote_;
#[doc = " ovrInputStateHeadset describes the complete input state for the"]
#[doc = " GearVR headset. The TrackpadPosition coordinates return for the"]
#[doc = " headset are relative coordinates, centered at (1280,720). See the"]
#[doc = " comments on ovrInputHeadsetCapabilities for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateHeadset_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    #[doc = " finger contact status for trackpad"]
    #[doc = " true = finger is on trackpad, false = finger is off trackpad"]
    pub TrackpadStatus: u32,
    #[doc = " X and Y coordinates of the Trackpad"]
    pub TrackpadPosition: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeadset_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHeadset_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrInputStateHeadset_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHeadset_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHeadset_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHeadset_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHeadset_>())).Buttons as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeadset_>())).TrackpadStatus as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(TrackpadStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeadset_>())).TrackpadPosition as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(TrackpadPosition)
        )
    );
}
#[doc = " ovrInputStateHeadset describes the complete input state for the"]
#[doc = " GearVR headset. The TrackpadPosition coordinates return for the"]
#[doc = " headset are relative coordinates, centered at (1280,720). See the"]
#[doc = " comments on ovrInputHeadsetCapabilities for more information."]
pub type ovrInputStateHeadset = ovrInputStateHeadset_;
#[doc = " ovrInputStateGamepad describes the input state gamepad input devices"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateGamepad_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    pub LeftTrigger: f32,
    pub RightTrigger: f32,
    #[doc = " X and Y coordinates of the Left Joystick, -1.0 - 1.0"]
    pub LeftJoystick: ovrVector2f,
    #[doc = " X and Y coordinates of the Right Joystick, -1.0 - 1.0"]
    pub RightJoystick: ovrVector2f,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputStateGamepad_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateGamepad_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateGamepad_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Buttons as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftTrigger as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightTrigger as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftJoystick as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftJoystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightJoystick as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightJoystick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " ovrInputStateGamepad describes the input state gamepad input devices"]
pub type ovrInputStateGamepad = ovrInputStateGamepad_;
extern "C" {
    #[doc = " Enumerates the input devices connected to the system"]
    #[doc = " Start with index=0 and counting up. Stop when ovrResult is < 0"]
    #[doc = ""]
    #[doc = " Input: ovrMobile, device index, and a capabilities header"]
    #[doc = " The capabilities header does not need to have any fields set before calling."]
    #[doc = " Output: capabilitiesHeader with information for that enumeration index"]
    pub fn vrapi_EnumerateInputDevices(
        ovr: *mut ovrMobile,
        index: u32,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the capabilities of the input device for the corresponding device ID"]
    #[doc = ""]
    #[doc = " Input: ovr, pointer to a capabilities structure"]
    #[doc = " Output: capabilities will be filled with information for the deviceID"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the capabilitiesHeader must be set when calling this function."]
    #[doc = "     Normally the capabilitiesHeader is obtained from the vrapi_EnumerateInputDevices API"]
    #[doc = "     The Type field in the header should match the structure type that is passed."]
    #[doc = ""]
    #[doc = "         ovrInputCapabilityHeader capsHeader;"]
    #[doc = "         if ( vrapi_EnumerateInputDevices( ovr, deviceIndex, &capsHeader ) >= 0 ) {"]
    #[doc = "             if ( capsHeader.Type == ovrDeviceType_TrackedRemote ) {"]
    #[doc = "                 ovrInputTrackedRemoteCapabilities remoteCaps;"]
    #[doc = "                 remoteCaps.Header = capsHeader;"]
    #[doc = "                 vrapi_GetInputDeviceCapabilities( ovr, &remoteCaps.Header );"]
    pub fn vrapi_GetInputDeviceCapabilities(
        ovr: *mut ovrMobile,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Sets the vibration level of a haptic device."]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, intensity: 0.0 - 1.0"]
    pub fn vrapi_SetHapticVibrationSimple(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        intensity: f32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Fills the haptic vibration buffer of a haptic device"]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, pointer to a hapticBuffer with filled in data."]
    pub fn vrapi_SetHapticVibrationBuffer(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        hapticBuffer: *const ovrHapticBuffer,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the current input state for controllers, without positional tracking info."]
    #[doc = ""]
    #[doc = " Input: ovr, deviceID, pointer to a capabilities structure (with Type field set)"]
    #[doc = " Output: Upon return the inputState structure will be set to the device's current input state"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the passed ovrInputStateHeader must be set to the type that"]
    #[doc = "     corresponds to the type of structure being passed."]
    #[doc = "     The pointer to the ovrInputStateHeader should be a pointer to a Header field in"]
    #[doc = "     structure matching the value of the Type field."]
    #[doc = ""]
    #[doc = "     ovrInputStateTrackedRemote state;"]
    #[doc = "     state.Header.Type = ovrControllerType_TrackedRemote;"]
    #[doc = "     if ( vrapi_GetCurrentInputState( ovr, remoteDeviceID, &state.Header ) >= 0 ) {"]
    pub fn vrapi_GetCurrentInputState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        inputState: *mut ovrInputStateHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the predicted input state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = " Input: ovr, device ID, prediction time"]
    #[doc = " Output: ovrTracking structure containing the device's predicted tracking state."]
    pub fn vrapi_GetInputTrackingState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        absTimeInSeconds: f64,
        tracking: *mut ovrTracking,
    ) -> ovrResult;
}
extern "C" {
    pub fn vrapi_RecenterInputPose(ovr: *mut ovrMobile, deviceID: ovrDeviceID);
}
extern "C" {
    #[doc = " Enable or disable emulation for the GearVR Controller."]
    #[doc = " Emulation is false by default."]
    #[doc = " If emulationOn == true, then the back button and touch events on the GearVR Controller will be sent through the Android"]
    #[doc = " dispatchKeyEvent and dispatchTouchEvent path as if they were from the headset back button and touchpad."]
    #[doc = " Applications that are intentionally enumerating the controller will likely want to turn emulation off in order"]
    #[doc = " to differentiate between controller and headset input events."]
    pub fn vrapi_SetRemoteEmulation(ovr: *mut ovrMobile, emulationOn: bool) -> ovrResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameInit {
    VRAPI_FRAME_INIT_DEFAULT = 0,
    VRAPI_FRAME_INIT_BLACK = 1,
    VRAPI_FRAME_INIT_BLACK_FLUSH = 2,
    VRAPI_FRAME_INIT_BLACK_FINAL = 3,
    VRAPI_FRAME_INIT_LOADING_ICON = 4,
    VRAPI_FRAME_INIT_LOADING_ICON_FLUSH = 5,
}

/* automatically generated by rust-bindgen */

pub const VRAPI_PRODUCT_VERSION: u32 = 1;
pub const VRAPI_MAJOR_VERSION: u32 = 1;
pub const VRAPI_MINOR_VERSION: u32 = 26;
pub const VRAPI_PATCH_VERSION: u32 = 0;
pub const VRAPI_BUILD_VERSION: u32 = 171664428;
pub const VRAPI_BUILD_DESCRIPTION: &'static [u8; 12usize] = b"Development\0";
pub const VRAPI_DRIVER_VERSION: u32 = 171664428;
pub const VRAPI_PI: f64 = 3.141592653589793;
pub const VRAPI_ZNEAR: f64 = 0.1;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type jint = ::std::os::raw::c_int;
pub type jlong = ::std::os::raw::c_long;
pub type jbyte = ::std::os::raw::c_schar;
pub type jboolean = ::std::os::raw::c_uchar;
pub type jchar = ::std::os::raw::c_ushort;
pub type jshort = ::std::os::raw::c_short;
pub type jfloat = f32;
pub type jdouble = f64;
pub type jsize = jint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jobject {
    _unused: [u8; 0],
}
pub type jobject = *mut _jobject;
pub type jclass = jobject;
pub type jthrowable = jobject;
pub type jstring = jobject;
pub type jarray = jobject;
pub type jbooleanArray = jarray;
pub type jbyteArray = jarray;
pub type jcharArray = jarray;
pub type jshortArray = jarray;
pub type jintArray = jarray;
pub type jlongArray = jarray;
pub type jfloatArray = jarray;
pub type jdoubleArray = jarray;
pub type jobjectArray = jarray;
pub type jweak = jobject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union jvalue {
    pub z: jboolean,
    pub b: jbyte,
    pub c: jchar,
    pub s: jshort,
    pub i: jint,
    pub j: jlong,
    pub f: jfloat,
    pub d: jdouble,
    pub l: jobject,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_jvalue() {
    assert_eq!(
        ::std::mem::size_of::<jvalue>(),
        8usize,
        concat!("Size of: ", stringify!(jvalue))
    );
    assert_eq!(
        ::std::mem::align_of::<jvalue>(),
        8usize,
        concat!("Alignment of ", stringify!(jvalue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).z as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).c as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).i as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).j as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(j))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).f as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).d as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<jvalue>())).l as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(jvalue), "::", stringify!(l))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jfieldID {
    _unused: [u8; 0],
}
pub type jfieldID = *mut _jfieldID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmethodID {
    _unused: [u8; 0],
}
pub type jmethodID = *mut _jmethodID;
pub const _jobjectType_JNIInvalidRefType: _jobjectType = 0;
pub const _jobjectType_JNILocalRefType: _jobjectType = 1;
pub const _jobjectType_JNIGlobalRefType: _jobjectType = 2;
pub const _jobjectType_JNIWeakGlobalRefType: _jobjectType = 3;
pub type _jobjectType = u32;
pub use self::_jobjectType as jobjectRefType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNINativeMethod {
    pub name: *mut ::std::os::raw::c_char,
    pub signature: *mut ::std::os::raw::c_char,
    pub fnPtr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_JNINativeMethod() {
    assert_eq!(
        ::std::mem::size_of::<JNINativeMethod>(),
        24usize,
        concat!("Size of: ", stringify!(JNINativeMethod))
    );
    assert_eq!(
        ::std::mem::align_of::<JNINativeMethod>(),
        8usize,
        concat!("Alignment of ", stringify!(JNINativeMethod))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeMethod>())).fnPtr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeMethod),
            "::",
            stringify!(fnPtr)
        )
    );
}
pub type JNIEnv = *const JNINativeInterface_;
pub type JavaVM = *const JNIInvokeInterface_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNINativeInterface_ {
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
    pub reserved3: *mut ::std::os::raw::c_void,
    pub GetVersion: ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv) -> jint>,
    pub DefineClass: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            name: *const ::std::os::raw::c_char,
            loader: jobject,
            buf: *const jbyte,
            len: jsize,
        ) -> jclass,
    >,
    pub FindClass: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, name: *const ::std::os::raw::c_char) -> jclass,
    >,
    pub FromReflectedMethod:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, method: jobject) -> jmethodID>,
    pub FromReflectedField:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, field: jobject) -> jfieldID>,
    pub ToReflectedMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            cls: jclass,
            methodID: jmethodID,
            isStatic: jboolean,
        ) -> jobject,
    >,
    pub GetSuperclass:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, sub: jclass) -> jclass>,
    pub IsAssignableFrom: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, sub: jclass, sup: jclass) -> jboolean,
    >,
    pub ToReflectedField: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            cls: jclass,
            fieldID: jfieldID,
            isStatic: jboolean,
        ) -> jobject,
    >,
    pub Throw:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jthrowable) -> jint>,
    pub ThrowNew: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            msg: *const ::std::os::raw::c_char,
        ) -> jint,
    >,
    pub ExceptionOccurred:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv) -> jthrowable>,
    pub ExceptionDescribe: ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv)>,
    pub ExceptionClear: ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv)>,
    pub FatalError: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, msg: *const ::std::os::raw::c_char),
    >,
    pub PushLocalFrame:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, capacity: jint) -> jint>,
    pub PopLocalFrame:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, result: jobject) -> jobject>,
    pub NewGlobalRef:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, lobj: jobject) -> jobject>,
    pub DeleteGlobalRef:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, gref: jobject)>,
    pub DeleteLocalRef: ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject)>,
    pub IsSameObject: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj1: jobject, obj2: jobject) -> jboolean,
    >,
    pub NewLocalRef:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, ref_: jobject) -> jobject>,
    pub EnsureLocalCapacity:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, capacity: jint) -> jint>,
    pub AllocObject:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass) -> jobject>,
    pub NewObject: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jobject,
    >,
    pub NewObjectV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jobject,
    >,
    pub NewObjectA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jobject,
    >,
    pub GetObjectClass:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject) -> jclass>,
    pub IsInstanceOf: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, clazz: jclass) -> jboolean,
    >,
    pub GetMethodID: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            name: *const ::std::os::raw::c_char,
            sig: *const ::std::os::raw::c_char,
        ) -> jmethodID,
    >,
    pub CallObjectMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jobject,
    >,
    pub CallObjectMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jobject,
    >,
    pub CallObjectMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jobject,
    >,
    pub CallBooleanMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jboolean,
    >,
    pub CallBooleanMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jboolean,
    >,
    pub CallBooleanMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jboolean,
    >,
    pub CallByteMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jbyte,
    >,
    pub CallByteMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jbyte,
    >,
    pub CallByteMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jbyte,
    >,
    pub CallCharMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jchar,
    >,
    pub CallCharMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jchar,
    >,
    pub CallCharMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jchar,
    >,
    pub CallShortMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jshort,
    >,
    pub CallShortMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jshort,
    >,
    pub CallShortMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jshort,
    >,
    pub CallIntMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jint,
    >,
    pub CallIntMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jint,
    >,
    pub CallIntMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jint,
    >,
    pub CallLongMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jlong,
    >,
    pub CallLongMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jlong,
    >,
    pub CallLongMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jlong,
    >,
    pub CallFloatMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jfloat,
    >,
    pub CallFloatMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jfloat,
    >,
    pub CallFloatMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jfloat,
    >,
    pub CallDoubleMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...) -> jdouble,
    >,
    pub CallDoubleMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jdouble,
    >,
    pub CallDoubleMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jdouble,
    >,
    pub CallVoidMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, methodID: jmethodID, ...),
    >,
    pub CallVoidMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ),
    >,
    pub CallVoidMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            methodID: jmethodID,
            args: *const jvalue,
        ),
    >,
    pub CallNonvirtualObjectMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jobject,
    >,
    pub CallNonvirtualObjectMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jobject,
    >,
    pub CallNonvirtualObjectMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jobject,
    >,
    pub CallNonvirtualBooleanMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jboolean,
    >,
    pub CallNonvirtualBooleanMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jboolean,
    >,
    pub CallNonvirtualBooleanMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jboolean,
    >,
    pub CallNonvirtualByteMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jbyte,
    >,
    pub CallNonvirtualByteMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jbyte,
    >,
    pub CallNonvirtualByteMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jbyte,
    >,
    pub CallNonvirtualCharMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jchar,
    >,
    pub CallNonvirtualCharMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jchar,
    >,
    pub CallNonvirtualCharMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jchar,
    >,
    pub CallNonvirtualShortMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jshort,
    >,
    pub CallNonvirtualShortMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jshort,
    >,
    pub CallNonvirtualShortMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jshort,
    >,
    pub CallNonvirtualIntMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jint,
    >,
    pub CallNonvirtualIntMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jint,
    >,
    pub CallNonvirtualIntMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jint,
    >,
    pub CallNonvirtualLongMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jlong,
    >,
    pub CallNonvirtualLongMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jlong,
    >,
    pub CallNonvirtualLongMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jlong,
    >,
    pub CallNonvirtualFloatMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jfloat,
    >,
    pub CallNonvirtualFloatMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jfloat,
    >,
    pub CallNonvirtualFloatMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jfloat,
    >,
    pub CallNonvirtualDoubleMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ) -> jdouble,
    >,
    pub CallNonvirtualDoubleMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jdouble,
    >,
    pub CallNonvirtualDoubleMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jdouble,
    >,
    pub CallNonvirtualVoidMethod: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            ...
        ),
    >,
    pub CallNonvirtualVoidMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ),
    >,
    pub CallNonvirtualVoidMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            obj: jobject,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ),
    >,
    pub GetFieldID: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            name: *const ::std::os::raw::c_char,
            sig: *const ::std::os::raw::c_char,
        ) -> jfieldID,
    >,
    pub GetObjectField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jobject,
    >,
    pub GetBooleanField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jboolean,
    >,
    pub GetByteField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jbyte,
    >,
    pub GetCharField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jchar,
    >,
    pub GetShortField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jshort,
    >,
    pub GetIntField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jint,
    >,
    pub GetLongField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jlong,
    >,
    pub GetFloatField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jfloat,
    >,
    pub GetDoubleField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID) -> jdouble,
    >,
    pub SetObjectField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jobject),
    >,
    pub SetBooleanField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jboolean),
    >,
    pub SetByteField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jbyte),
    >,
    pub SetCharField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jchar),
    >,
    pub SetShortField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jshort),
    >,
    pub SetIntField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jint),
    >,
    pub SetLongField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jlong),
    >,
    pub SetFloatField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jfloat),
    >,
    pub SetDoubleField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject, fieldID: jfieldID, val: jdouble),
    >,
    pub GetStaticMethodID: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            name: *const ::std::os::raw::c_char,
            sig: *const ::std::os::raw::c_char,
        ) -> jmethodID,
    >,
    pub CallStaticObjectMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jobject,
    >,
    pub CallStaticObjectMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jobject,
    >,
    pub CallStaticObjectMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jobject,
    >,
    pub CallStaticBooleanMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jboolean,
    >,
    pub CallStaticBooleanMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jboolean,
    >,
    pub CallStaticBooleanMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jboolean,
    >,
    pub CallStaticByteMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jbyte,
    >,
    pub CallStaticByteMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jbyte,
    >,
    pub CallStaticByteMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jbyte,
    >,
    pub CallStaticCharMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jchar,
    >,
    pub CallStaticCharMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jchar,
    >,
    pub CallStaticCharMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jchar,
    >,
    pub CallStaticShortMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jshort,
    >,
    pub CallStaticShortMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jshort,
    >,
    pub CallStaticShortMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jshort,
    >,
    pub CallStaticIntMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jint,
    >,
    pub CallStaticIntMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jint,
    >,
    pub CallStaticIntMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jint,
    >,
    pub CallStaticLongMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jlong,
    >,
    pub CallStaticLongMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jlong,
    >,
    pub CallStaticLongMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jlong,
    >,
    pub CallStaticFloatMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jfloat,
    >,
    pub CallStaticFloatMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jfloat,
    >,
    pub CallStaticFloatMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jfloat,
    >,
    pub CallStaticDoubleMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, methodID: jmethodID, ...) -> jdouble,
    >,
    pub CallStaticDoubleMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ) -> jdouble,
    >,
    pub CallStaticDoubleMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ) -> jdouble,
    >,
    pub CallStaticVoidMethod: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, cls: jclass, methodID: jmethodID, ...),
    >,
    pub CallStaticVoidMethodV: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            cls: jclass,
            methodID: jmethodID,
            args: *mut __va_list_tag,
        ),
    >,
    pub CallStaticVoidMethodA: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            cls: jclass,
            methodID: jmethodID,
            args: *const jvalue,
        ),
    >,
    pub GetStaticFieldID: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            name: *const ::std::os::raw::c_char,
            sig: *const ::std::os::raw::c_char,
        ) -> jfieldID,
    >,
    pub GetStaticObjectField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jobject,
    >,
    pub GetStaticBooleanField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jboolean,
    >,
    pub GetStaticByteField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jbyte,
    >,
    pub GetStaticCharField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jchar,
    >,
    pub GetStaticShortField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jshort,
    >,
    pub GetStaticIntField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jint,
    >,
    pub GetStaticLongField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jlong,
    >,
    pub GetStaticFloatField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jfloat,
    >,
    pub GetStaticDoubleField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID) -> jdouble,
    >,
    pub SetStaticObjectField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jobject),
    >,
    pub SetStaticBooleanField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jboolean),
    >,
    pub SetStaticByteField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jbyte),
    >,
    pub SetStaticCharField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jchar),
    >,
    pub SetStaticShortField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jshort),
    >,
    pub SetStaticIntField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jint),
    >,
    pub SetStaticLongField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jlong),
    >,
    pub SetStaticFloatField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jfloat),
    >,
    pub SetStaticDoubleField: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass, fieldID: jfieldID, value: jdouble),
    >,
    pub NewString: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, unicode: *const jchar, len: jsize) -> jstring,
    >,
    pub GetStringLength:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, str: jstring) -> jsize>,
    pub GetStringChars: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, str: jstring, isCopy: *mut jboolean) -> *const jchar,
    >,
    pub ReleaseStringChars: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, str: jstring, chars: *const jchar),
    >,
    pub NewStringUTF: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, utf: *const ::std::os::raw::c_char) -> jstring,
    >,
    pub GetStringUTFLength:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, str: jstring) -> jsize>,
    pub GetStringUTFChars: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            str: jstring,
            isCopy: *mut jboolean,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub ReleaseStringUTFChars: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, str: jstring, chars: *const ::std::os::raw::c_char),
    >,
    pub GetArrayLength:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, array: jarray) -> jsize>,
    pub NewObjectArray: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            len: jsize,
            clazz: jclass,
            init: jobject,
        ) -> jobjectArray,
    >,
    pub GetObjectArrayElement: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jobjectArray, index: jsize) -> jobject,
    >,
    pub SetObjectArrayElement: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jobjectArray, index: jsize, val: jobject),
    >,
    pub NewBooleanArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jbooleanArray>,
    pub NewByteArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jbyteArray>,
    pub NewCharArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jcharArray>,
    pub NewShortArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jshortArray>,
    pub NewIntArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jintArray>,
    pub NewLongArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jlongArray>,
    pub NewFloatArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jfloatArray>,
    pub NewDoubleArray:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, len: jsize) -> jdoubleArray>,
    pub GetBooleanArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbooleanArray,
            isCopy: *mut jboolean,
        ) -> *mut jboolean,
    >,
    pub GetByteArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbyteArray,
            isCopy: *mut jboolean,
        ) -> *mut jbyte,
    >,
    pub GetCharArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jcharArray,
            isCopy: *mut jboolean,
        ) -> *mut jchar,
    >,
    pub GetShortArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jshortArray,
            isCopy: *mut jboolean,
        ) -> *mut jshort,
    >,
    pub GetIntArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jintArray,
            isCopy: *mut jboolean,
        ) -> *mut jint,
    >,
    pub GetLongArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jlongArray,
            isCopy: *mut jboolean,
        ) -> *mut jlong,
    >,
    pub GetFloatArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jfloatArray,
            isCopy: *mut jboolean,
        ) -> *mut jfloat,
    >,
    pub GetDoubleArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jdoubleArray,
            isCopy: *mut jboolean,
        ) -> *mut jdouble,
    >,
    pub ReleaseBooleanArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbooleanArray,
            elems: *mut jboolean,
            mode: jint,
        ),
    >,
    pub ReleaseByteArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jbyteArray, elems: *mut jbyte, mode: jint),
    >,
    pub ReleaseCharArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jcharArray, elems: *mut jchar, mode: jint),
    >,
    pub ReleaseShortArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jshortArray, elems: *mut jshort, mode: jint),
    >,
    pub ReleaseIntArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jintArray, elems: *mut jint, mode: jint),
    >,
    pub ReleaseLongArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jlongArray, elems: *mut jlong, mode: jint),
    >,
    pub ReleaseFloatArrayElements: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, array: jfloatArray, elems: *mut jfloat, mode: jint),
    >,
    pub ReleaseDoubleArrayElements: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jdoubleArray,
            elems: *mut jdouble,
            mode: jint,
        ),
    >,
    pub GetBooleanArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbooleanArray,
            start: jsize,
            l: jsize,
            buf: *mut jboolean,
        ),
    >,
    pub GetByteArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbyteArray,
            start: jsize,
            len: jsize,
            buf: *mut jbyte,
        ),
    >,
    pub GetCharArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jcharArray,
            start: jsize,
            len: jsize,
            buf: *mut jchar,
        ),
    >,
    pub GetShortArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jshortArray,
            start: jsize,
            len: jsize,
            buf: *mut jshort,
        ),
    >,
    pub GetIntArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jintArray,
            start: jsize,
            len: jsize,
            buf: *mut jint,
        ),
    >,
    pub GetLongArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jlongArray,
            start: jsize,
            len: jsize,
            buf: *mut jlong,
        ),
    >,
    pub GetFloatArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jfloatArray,
            start: jsize,
            len: jsize,
            buf: *mut jfloat,
        ),
    >,
    pub GetDoubleArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jdoubleArray,
            start: jsize,
            len: jsize,
            buf: *mut jdouble,
        ),
    >,
    pub SetBooleanArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbooleanArray,
            start: jsize,
            l: jsize,
            buf: *const jboolean,
        ),
    >,
    pub SetByteArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jbyteArray,
            start: jsize,
            len: jsize,
            buf: *const jbyte,
        ),
    >,
    pub SetCharArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jcharArray,
            start: jsize,
            len: jsize,
            buf: *const jchar,
        ),
    >,
    pub SetShortArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jshortArray,
            start: jsize,
            len: jsize,
            buf: *const jshort,
        ),
    >,
    pub SetIntArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jintArray,
            start: jsize,
            len: jsize,
            buf: *const jint,
        ),
    >,
    pub SetLongArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jlongArray,
            start: jsize,
            len: jsize,
            buf: *const jlong,
        ),
    >,
    pub SetFloatArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jfloatArray,
            start: jsize,
            len: jsize,
            buf: *const jfloat,
        ),
    >,
    pub SetDoubleArrayRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jdoubleArray,
            start: jsize,
            len: jsize,
            buf: *const jdouble,
        ),
    >,
    pub RegisterNatives: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            clazz: jclass,
            methods: *const JNINativeMethod,
            nMethods: jint,
        ) -> jint,
    >,
    pub UnregisterNatives:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass) -> jint>,
    pub MonitorEnter:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject) -> jint>,
    pub MonitorExit:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject) -> jint>,
    pub GetJavaVM:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, vm: *mut *mut JavaVM) -> jint>,
    pub GetStringRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            str: jstring,
            start: jsize,
            len: jsize,
            buf: *mut jchar,
        ),
    >,
    pub GetStringUTFRegion: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            str: jstring,
            start: jsize,
            len: jsize,
            buf: *mut ::std::os::raw::c_char,
        ),
    >,
    pub GetPrimitiveArrayCritical: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jarray,
            isCopy: *mut jboolean,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub ReleasePrimitiveArrayCritical: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            array: jarray,
            carray: *mut ::std::os::raw::c_void,
            mode: jint,
        ),
    >,
    pub GetStringCritical: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            string: jstring,
            isCopy: *mut jboolean,
        ) -> *const jchar,
    >,
    pub ReleaseStringCritical: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, string: jstring, cstring: *const jchar),
    >,
    pub NewWeakGlobalRef:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject) -> jweak>,
    pub DeleteWeakGlobalRef:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, ref_: jweak)>,
    pub ExceptionCheck: ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv) -> jboolean>,
    pub NewDirectByteBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            env: *mut JNIEnv,
            address: *mut ::std::os::raw::c_void,
            capacity: jlong,
        ) -> jobject,
    >,
    pub GetDirectBufferAddress: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, buf: jobject) -> *mut ::std::os::raw::c_void,
    >,
    pub GetDirectBufferCapacity:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, buf: jobject) -> jlong>,
    pub GetObjectRefType: ::std::option::Option<
        unsafe extern "C" fn(env: *mut JNIEnv, obj: jobject) -> jobjectRefType,
    >,
    pub GetModule:
        ::std::option::Option<unsafe extern "C" fn(env: *mut JNIEnv, clazz: jclass) -> jobject>,
}
#[test]
fn bindgen_test_layout_JNINativeInterface_() {
    assert_eq!(
        ::std::mem::size_of::<JNINativeInterface_>(),
        1872usize,
        concat!("Size of: ", stringify!(JNINativeInterface_))
    );
    assert_eq!(
        ::std::mem::align_of::<JNINativeInterface_>(),
        8usize,
        concat!("Alignment of ", stringify!(JNINativeInterface_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).reserved0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).reserved3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetVersion as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).DefineClass as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(DefineClass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).FindClass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(FindClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).FromReflectedMethod as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(FromReflectedMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).FromReflectedField as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(FromReflectedField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ToReflectedMethod as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ToReflectedMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetSuperclass as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetSuperclass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).IsAssignableFrom as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(IsAssignableFrom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ToReflectedField as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ToReflectedField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).Throw as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(Throw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).ThrowNew as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ThrowNew)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ExceptionOccurred as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ExceptionOccurred)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ExceptionDescribe as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ExceptionDescribe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ExceptionClear as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ExceptionClear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).FatalError as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(FatalError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).PushLocalFrame as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(PushLocalFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).PopLocalFrame as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(PopLocalFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewGlobalRef as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewGlobalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).DeleteGlobalRef as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(DeleteGlobalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).DeleteLocalRef as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(DeleteLocalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).IsSameObject as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(IsSameObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewLocalRef as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewLocalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).EnsureLocalCapacity as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(EnsureLocalCapacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).AllocObject as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(AllocObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewObject as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewObjectV as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewObjectV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewObjectA as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewObjectA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetObjectClass as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetObjectClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).IsInstanceOf as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(IsInstanceOf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetMethodID as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetMethodID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallObjectMethod as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallObjectMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallObjectMethodV as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallObjectMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallObjectMethodA as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallObjectMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallBooleanMethod as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallBooleanMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallBooleanMethodV as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallBooleanMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallBooleanMethodA as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallBooleanMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallByteMethod as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallByteMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallByteMethodV as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallByteMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallByteMethodA as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallByteMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallCharMethod as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallCharMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallCharMethodV as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallCharMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallCharMethodA as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallCharMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallShortMethod as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallShortMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallShortMethodV as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallShortMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallShortMethodA as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallShortMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallIntMethod as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallIntMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallIntMethodV as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallIntMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallIntMethodA as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallIntMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallLongMethod as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallLongMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallLongMethodV as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallLongMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallLongMethodA as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallLongMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallFloatMethod as *const _ as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallFloatMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallFloatMethodV as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallFloatMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallFloatMethodA as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallFloatMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallDoubleMethod as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallDoubleMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallDoubleMethodV as *const _ as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallDoubleMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallDoubleMethodA as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallDoubleMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallVoidMethod as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallVoidMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallVoidMethodV as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallVoidMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallVoidMethodA as *const _ as usize
        },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallVoidMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualObjectMethod as *const _
                as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualObjectMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualObjectMethodV as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualObjectMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualObjectMethodA as *const _
                as usize
        },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualObjectMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualBooleanMethod as *const _
                as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualBooleanMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualBooleanMethodV as *const _
                as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualBooleanMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualBooleanMethodA as *const _
                as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualBooleanMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualByteMethod as *const _
                as usize
        },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualByteMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualByteMethodV as *const _
                as usize
        },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualByteMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualByteMethodA as *const _
                as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualByteMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualCharMethod as *const _
                as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualCharMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualCharMethodV as *const _
                as usize
        },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualCharMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualCharMethodA as *const _
                as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualCharMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualShortMethod as *const _
                as usize
        },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualShortMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualShortMethodV as *const _
                as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualShortMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualShortMethodA as *const _
                as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualShortMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualIntMethod as *const _
                as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualIntMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualIntMethodV as *const _
                as usize
        },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualIntMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualIntMethodA as *const _
                as usize
        },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualIntMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualLongMethod as *const _
                as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualLongMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualLongMethodV as *const _
                as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualLongMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualLongMethodA as *const _
                as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualLongMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualFloatMethod as *const _
                as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualFloatMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualFloatMethodV as *const _
                as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualFloatMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualFloatMethodA as *const _
                as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualFloatMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualDoubleMethod as *const _
                as usize
        },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualDoubleMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualDoubleMethodV as *const _
                as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualDoubleMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualDoubleMethodA as *const _
                as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualDoubleMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualVoidMethod as *const _
                as usize
        },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualVoidMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualVoidMethodV as *const _
                as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualVoidMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallNonvirtualVoidMethodA as *const _
                as usize
        },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallNonvirtualVoidMethodA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetFieldID as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetFieldID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetObjectField as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetObjectField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetBooleanField as *const _ as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetBooleanField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetByteField as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetByteField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetCharField as *const _ as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetCharField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetShortField as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetShortField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetIntField as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetIntField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetLongField as *const _ as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetLongField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetFloatField as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetFloatField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetDoubleField as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetDoubleField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetObjectField as *const _ as usize
        },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetObjectField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetBooleanField as *const _ as usize
        },
        840usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetBooleanField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetByteField as *const _ as usize
        },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetByteField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetCharField as *const _ as usize
        },
        856usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetCharField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetShortField as *const _ as usize
        },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetShortField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).SetIntField as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetIntField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetLongField as *const _ as usize
        },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetLongField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetFloatField as *const _ as usize
        },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetFloatField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetDoubleField as *const _ as usize
        },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetDoubleField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticMethodID as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticMethodID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticObjectMethod as *const _
                as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticObjectMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticObjectMethodV as *const _
                as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticObjectMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticObjectMethodA as *const _
                as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticObjectMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticBooleanMethod as *const _
                as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticBooleanMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticBooleanMethodV as *const _
                as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticBooleanMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticBooleanMethodA as *const _
                as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticBooleanMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticByteMethod as *const _
                as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticByteMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticByteMethodV as *const _
                as usize
        },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticByteMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticByteMethodA as *const _
                as usize
        },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticByteMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticCharMethod as *const _
                as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticCharMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticCharMethodV as *const _
                as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticCharMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticCharMethodA as *const _
                as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticCharMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticShortMethod as *const _
                as usize
        },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticShortMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticShortMethodV as *const _
                as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticShortMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticShortMethodA as *const _
                as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticShortMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticIntMethod as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticIntMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticIntMethodV as *const _
                as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticIntMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticIntMethodA as *const _
                as usize
        },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticIntMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticLongMethod as *const _
                as usize
        },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticLongMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticLongMethodV as *const _
                as usize
        },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticLongMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticLongMethodA as *const _
                as usize
        },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticLongMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticFloatMethod as *const _
                as usize
        },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticFloatMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticFloatMethodV as *const _
                as usize
        },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticFloatMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticFloatMethodA as *const _
                as usize
        },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticFloatMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticDoubleMethod as *const _
                as usize
        },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticDoubleMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticDoubleMethodV as *const _
                as usize
        },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticDoubleMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticDoubleMethodA as *const _
                as usize
        },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticDoubleMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticVoidMethod as *const _
                as usize
        },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticVoidMethod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticVoidMethodV as *const _
                as usize
        },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticVoidMethodV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).CallStaticVoidMethodA as *const _
                as usize
        },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(CallStaticVoidMethodA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticFieldID as *const _ as usize
        },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticFieldID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticObjectField as *const _
                as usize
        },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticObjectField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticBooleanField as *const _
                as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticBooleanField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticByteField as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticByteField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticCharField as *const _ as usize
        },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticCharField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticShortField as *const _ as usize
        },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticShortField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticIntField as *const _ as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticIntField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticLongField as *const _ as usize
        },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticLongField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticFloatField as *const _ as usize
        },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticFloatField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStaticDoubleField as *const _
                as usize
        },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStaticDoubleField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticObjectField as *const _
                as usize
        },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticObjectField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticBooleanField as *const _
                as usize
        },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticBooleanField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticByteField as *const _ as usize
        },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticByteField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticCharField as *const _ as usize
        },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticCharField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticShortField as *const _ as usize
        },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticShortField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticIntField as *const _ as usize
        },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticIntField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticLongField as *const _ as usize
        },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticLongField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticFloatField as *const _ as usize
        },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticFloatField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetStaticDoubleField as *const _
                as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetStaticDoubleField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewString as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringLength as *const _ as usize
        },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringChars as *const _ as usize
        },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseStringChars as *const _ as usize
        },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseStringChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewStringUTF as *const _ as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewStringUTF)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringUTFLength as *const _ as usize
        },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringUTFLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringUTFChars as *const _ as usize
        },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringUTFChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseStringUTFChars as *const _
                as usize
        },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseStringUTFChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetArrayLength as *const _ as usize
        },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetArrayLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewObjectArray as *const _ as usize
        },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewObjectArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetObjectArrayElement as *const _
                as usize
        },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetObjectArrayElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetObjectArrayElement as *const _
                as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetObjectArrayElement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewBooleanArray as *const _ as usize
        },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewBooleanArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewByteArray as *const _ as usize
        },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewByteArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewCharArray as *const _ as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewCharArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewShortArray as *const _ as usize
        },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewShortArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).NewIntArray as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewIntArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewLongArray as *const _ as usize
        },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewLongArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewFloatArray as *const _ as usize
        },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewFloatArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewDoubleArray as *const _ as usize
        },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewDoubleArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetBooleanArrayElements as *const _
                as usize
        },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetBooleanArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetByteArrayElements as *const _
                as usize
        },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetByteArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetCharArrayElements as *const _
                as usize
        },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetCharArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetShortArrayElements as *const _
                as usize
        },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetShortArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetIntArrayElements as *const _ as usize
        },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetIntArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetLongArrayElements as *const _
                as usize
        },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetLongArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetFloatArrayElements as *const _
                as usize
        },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetFloatArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetDoubleArrayElements as *const _
                as usize
        },
        1520usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetDoubleArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseBooleanArrayElements as *const _
                as usize
        },
        1528usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseBooleanArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseByteArrayElements as *const _
                as usize
        },
        1536usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseByteArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseCharArrayElements as *const _
                as usize
        },
        1544usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseCharArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseShortArrayElements as *const _
                as usize
        },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseShortArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseIntArrayElements as *const _
                as usize
        },
        1560usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseIntArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseLongArrayElements as *const _
                as usize
        },
        1568usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseLongArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseFloatArrayElements as *const _
                as usize
        },
        1576usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseFloatArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseDoubleArrayElements as *const _
                as usize
        },
        1584usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseDoubleArrayElements)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetBooleanArrayRegion as *const _
                as usize
        },
        1592usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetBooleanArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetByteArrayRegion as *const _ as usize
        },
        1600usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetByteArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetCharArrayRegion as *const _ as usize
        },
        1608usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetCharArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetShortArrayRegion as *const _ as usize
        },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetShortArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetIntArrayRegion as *const _ as usize
        },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetIntArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetLongArrayRegion as *const _ as usize
        },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetLongArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetFloatArrayRegion as *const _ as usize
        },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetFloatArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetDoubleArrayRegion as *const _
                as usize
        },
        1648usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetDoubleArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetBooleanArrayRegion as *const _
                as usize
        },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetBooleanArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetByteArrayRegion as *const _ as usize
        },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetByteArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetCharArrayRegion as *const _ as usize
        },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetCharArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetShortArrayRegion as *const _ as usize
        },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetShortArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetIntArrayRegion as *const _ as usize
        },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetIntArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetLongArrayRegion as *const _ as usize
        },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetLongArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetFloatArrayRegion as *const _ as usize
        },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetFloatArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).SetDoubleArrayRegion as *const _
                as usize
        },
        1712usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(SetDoubleArrayRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).RegisterNatives as *const _ as usize
        },
        1720usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(RegisterNatives)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).UnregisterNatives as *const _ as usize
        },
        1728usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(UnregisterNatives)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).MonitorEnter as *const _ as usize
        },
        1736usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(MonitorEnter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).MonitorExit as *const _ as usize },
        1744usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(MonitorExit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetJavaVM as *const _ as usize },
        1752usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetJavaVM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringRegion as *const _ as usize
        },
        1760usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringUTFRegion as *const _ as usize
        },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringUTFRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetPrimitiveArrayCritical as *const _
                as usize
        },
        1776usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetPrimitiveArrayCritical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleasePrimitiveArrayCritical
                as *const _ as usize
        },
        1784usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleasePrimitiveArrayCritical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetStringCritical as *const _ as usize
        },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetStringCritical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ReleaseStringCritical as *const _
                as usize
        },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ReleaseStringCritical)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewWeakGlobalRef as *const _ as usize
        },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewWeakGlobalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).DeleteWeakGlobalRef as *const _ as usize
        },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(DeleteWeakGlobalRef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).ExceptionCheck as *const _ as usize
        },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(ExceptionCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).NewDirectByteBuffer as *const _ as usize
        },
        1832usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(NewDirectByteBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetDirectBufferAddress as *const _
                as usize
        },
        1840usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetDirectBufferAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetDirectBufferCapacity as *const _
                as usize
        },
        1848usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetDirectBufferCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNINativeInterface_>())).GetObjectRefType as *const _ as usize
        },
        1856usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetObjectRefType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNINativeInterface_>())).GetModule as *const _ as usize },
        1864usize,
        concat!(
            "Offset of field: ",
            stringify!(JNINativeInterface_),
            "::",
            stringify!(GetModule)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JNIInvokeInterface_ {
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
    pub DestroyJavaVM: ::std::option::Option<unsafe extern "C" fn(vm: *mut JavaVM) -> jint>,
    pub AttachCurrentThread: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut JavaVM,
            penv: *mut *mut ::std::os::raw::c_void,
            args: *mut ::std::os::raw::c_void,
        ) -> jint,
    >,
    pub DetachCurrentThread: ::std::option::Option<unsafe extern "C" fn(vm: *mut JavaVM) -> jint>,
    pub GetEnv: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut JavaVM,
            penv: *mut *mut ::std::os::raw::c_void,
            version: jint,
        ) -> jint,
    >,
    pub AttachCurrentThreadAsDaemon: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut JavaVM,
            penv: *mut *mut ::std::os::raw::c_void,
            args: *mut ::std::os::raw::c_void,
        ) -> jint,
    >,
}
#[test]
fn bindgen_test_layout_JNIInvokeInterface_() {
    assert_eq!(
        ::std::mem::size_of::<JNIInvokeInterface_>(),
        64usize,
        concat!("Size of: ", stringify!(JNIInvokeInterface_))
    );
    assert_eq!(
        ::std::mem::align_of::<JNIInvokeInterface_>(),
        8usize,
        concat!("Alignment of ", stringify!(JNIInvokeInterface_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNIInvokeInterface_>())).reserved0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNIInvokeInterface_>())).reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNIInvokeInterface_>())).reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNIInvokeInterface_>())).DestroyJavaVM as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(DestroyJavaVM)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNIInvokeInterface_>())).AttachCurrentThread as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(AttachCurrentThread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNIInvokeInterface_>())).DetachCurrentThread as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(DetachCurrentThread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JNIInvokeInterface_>())).GetEnv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(GetEnv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JNIInvokeInterface_>())).AttachCurrentThreadAsDaemon as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JNIInvokeInterface_),
            "::",
            stringify!(AttachCurrentThreadAsDaemon)
        )
    );
}
#[doc = " Java details about an activity"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrJava_ {
    pub Vm: *mut JavaVM,
    pub Env: *mut JNIEnv,
    pub ActivityObject: jobject,
}
#[test]
fn bindgen_test_layout_ovrJava_() {
    assert_eq!(
        ::std::mem::size_of::<ovrJava_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrJava_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrJava_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrJava_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Vm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Vm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).Env as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(Env)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrJava_>())).ActivityObject as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrJava_),
            "::",
            stringify!(ActivityObject)
        )
    );
}
#[doc = " Java details about an activity"]
pub type ovrJava = ovrJava_;
pub type ovrResult = ::std::os::raw::c_int;
#[repr(u32)]
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSuccessResult_ {
    ovrSuccess = 0,
    ovrSuccess_BoundaryInvalid = 1001,
}
#[doc = " ovrResult isn't actually an enum type and the the success / failure types are not"]
#[doc = " defined anywhere for GearVR VrApi. This needs to be remedied. For now, I'm defining"]
#[doc = " these here and will try to address this larger issue in a follow-on changeset."]
#[doc = " errors are < 0, successes are >= 0"]
#[doc = " Except where noted, these match error codes from PC CAPI."]
pub use self::ovrSuccessResult_ as ovrSuccessResult;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrErrorResult_ {
    ovrError_MemoryAllocationFailure = -1000,
    ovrError_NotInitialized = -1004,
    ovrError_InvalidParameter = -1005,
    ovrError_DeviceUnavailable = -1010,
    ovrError_InvalidOperation = -1015,
    ovrError_UnsupportedDeviceType = -1050,
    ovrError_NoDevice = -1051,
    ovrError_NotImplemented = -1052,
    ovrResult_EnumSize = 2147483647,
}
pub use self::ovrErrorResult_ as ovrErrorResult;
#[doc = " A 2D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector2f_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_ovrVector2f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector2f_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector2f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector2f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector2f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector2f_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A 2D vector."]
pub type ovrVector2f = ovrVector2f_;
#[doc = " A 3D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector3f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_ovrVector3f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector3f_>(),
        12usize,
        concat!("Size of: ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector3f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector3f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector3f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector3f_),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " A 3D vector."]
pub type ovrVector3f = ovrVector3f_;
#[doc = " A 4D vector."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrVector4f_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrVector4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrVector4f_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrVector4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrVector4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrVector4f_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrVector4f_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " A 4D vector."]
pub type ovrVector4f = ovrVector4f_;
#[doc = " Quaternion."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrQuatf_ {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_ovrQuatf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrQuatf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrQuatf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrQuatf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrQuatf_>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrQuatf_),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " Quaternion."]
pub type ovrQuatf = ovrQuatf_;
#[doc = " Row-major 4x4 matrix."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMatrix4f_ {
    pub M: [[f32; 4usize]; 4usize],
}
#[test]
fn bindgen_test_layout_ovrMatrix4f_() {
    assert_eq!(
        ::std::mem::size_of::<ovrMatrix4f_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrMatrix4f_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrMatrix4f_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrMatrix4f_>())).M as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrMatrix4f_),
            "::",
            stringify!(M)
        )
    );
}
#[doc = " Row-major 4x4 matrix."]
pub type ovrMatrix4f = ovrMatrix4f_;
#[doc = " Position and orientation together."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrPosef_ {
    pub Orientation: ovrQuatf,
    pub __bindgen_anon_1: ovrPosef___bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrPosef___bindgen_ty_1 {
    pub Position: ovrVector3f,
    pub Translation: ovrVector3f,
    _bindgen_union_align: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_ovrPosef___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef___bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPosef___bindgen_ty_1>())).Translation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef___bindgen_ty_1),
            "::",
            stringify!(Translation)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPosef_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPosef_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPosef_>())).Orientation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPosef_),
            "::",
            stringify!(Orientation)
        )
    );
}
#[doc = " Position and orientation together."]
pub type ovrPosef = ovrPosef_;
#[doc = " A rectangle with 2D size and position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrRectf_ {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_ovrRectf_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRectf_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrRectf_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRectf_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrRectf_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRectf_>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRectf_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " A rectangle with 2D size and position."]
pub type ovrRectf = ovrRectf_;
#[repr(u32)]
#[doc = " True or false."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrBooleanResult_ {
    VRAPI_FALSE = 0,
    VRAPI_TRUE = 1,
}
#[doc = " True or false."]
pub use self::ovrBooleanResult_ as ovrBooleanResult;
#[repr(u32)]
#[doc = " One of the user's eyes."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrEye_ {
    VRAPI_EYE_LEFT = 0,
    VRAPI_EYE_RIGHT = 1,
    VRAPI_EYE_COUNT = 2,
}
#[doc = " One of the user's eyes."]
pub use self::ovrEye_ as ovrEye;
#[repr(u32)]
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrStructureType_ {
    VRAPI_STRUCTURE_TYPE_INIT_PARMS = 1,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS = 2,
    VRAPI_STRUCTURE_TYPE_FRAME_PARMS = 3,
    VRAPI_STRUCTURE_TYPE_MODE_PARMS_VULKAN = 5,
}
#[doc = " Defines a layout for ovrInitParms, ovrModeParms, or ovrFrameParms."]
pub use self::ovrStructureType_ as ovrStructureType;
impl ovrDeviceType_ {
    pub const VRAPI_DEVICE_TYPE_NOTE4: ovrDeviceType_ =
        ovrDeviceType_::VRAPI_DEVICE_TYPE_GEARVR_START;
}
impl ovrDeviceType_ {
    pub const VRAPI_DEVICE_TYPE_OCULUSGO: ovrDeviceType_ =
        ovrDeviceType_::VRAPI_DEVICE_TYPE_OCULUSGO_START;
}
#[repr(i32)]
#[doc = " A VR-capable device."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceType_ {
    VRAPI_DEVICE_TYPE_GEARVR_START = 0,
    VRAPI_DEVICE_TYPE_NOTE5 = 1,
    VRAPI_DEVICE_TYPE_S6 = 2,
    VRAPI_DEVICE_TYPE_S7 = 3,
    VRAPI_DEVICE_TYPE_NOTE7 = 4,
    VRAPI_DEVICE_TYPE_S8 = 5,
    VRAPI_DEVICE_TYPE_NOTE8 = 6,
    VRAPI_DEVICE_TYPE_NOTE7_FE = 7,
    VRAPI_DEVICE_TYPE_A8 = 8,
    VRAPI_DEVICE_TYPE_A8_PLUS = 9,
    VRAPI_DEVICE_TYPE_S9 = 10,
    VRAPI_DEVICE_TYPE_S9_PLUS = 11,
    VRAPI_DEVICE_TYPE_A8_STAR = 12,
    VRAPI_DEVICE_TYPE_NOTE9 = 13,
    VRAPI_DEVICE_TYPE_A9_2018 = 14,
    VRAPI_DEVICE_TYPE_S10 = 15,
    VRAPI_DEVICE_TYPE_GEARVR_END = 63,
    VRAPI_DEVICE_TYPE_OCULUSGO_START = 64,
    VRAPI_DEVICE_TYPE_MIVR_STANDALONE = 65,
    VRAPI_DEVICE_TYPE_OCULUSGO_END = 127,
    VRAPI_DEVICE_TYPE_OCULUSQUEST_START = 256,
    VRAPI_DEVICE_TYPE_OCULUSQUEST = 259,
    VRAPI_DEVICE_TYPE_OCULUSQUEST_END = 319,
    VRAPI_DEVICE_TYPE_UNKNOWN = -1,
}
#[doc = " A VR-capable device."]
pub use self::ovrDeviceType_ as ovrDeviceType;
#[repr(i32)]
#[doc = " A headset, which typically includes optics and tracking hardware, but not necessarily the device itself."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrHeadsetType_ {
    VRAPI_HEADSET_TYPE_R320 = 0,
    VRAPI_HEADSET_TYPE_R321 = 1,
    VRAPI_HEADSET_TYPE_R322 = 2,
    VRAPI_HEADSET_TYPE_R323 = 3,
    VRAPI_HEADSET_TYPE_R324 = 4,
    VRAPI_HEADSET_TYPE_R325 = 5,
    VRAPI_HEADSET_TYPE_OCULUSGO = 64,
    VRAPI_HEADSET_TYPE_MIVR_STANDALONE = 65,
    VRAPI_HEADSET_TYPE_OCULUSQUEST = 256,
    VRAPI_HEADSET_TYPE_UNKNOWN = -1,
}
#[doc = " A headset, which typically includes optics and tracking hardware, but not necessarily the device itself."]
pub use self::ovrHeadsetType_ as ovrHeadsetType;
#[repr(u32)]
#[doc = " A geographic region authorized for certain hardware and content."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceRegion_ {
    VRAPI_DEVICE_REGION_UNSPECIFIED = 0,
    VRAPI_DEVICE_REGION_JAPAN = 1,
    VRAPI_DEVICE_REGION_CHINA = 2,
}
#[doc = " A geographic region authorized for certain hardware and content."]
pub use self::ovrDeviceRegion_ as ovrDeviceRegion;
#[repr(u32)]
#[doc = " The maximum resolution and framerate supported by a video decoder."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrVideoDecoderLimit_ {
    VRAPI_VIDEO_DECODER_LIMIT_4K_30FPS = 0,
    VRAPI_VIDEO_DECODER_LIMIT_4K_60FPS = 1,
}
#[doc = " The maximum resolution and framerate supported by a video decoder."]
pub use self::ovrVideoDecoderLimit_ as ovrVideoDecoderLimit;
#[repr(u32)]
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against != VRAPI_DEVICE_EMULATION_MODE_NONE"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceEmulationMode_ {
    VRAPI_DEVICE_EMULATION_MODE_NONE = 0,
    VRAPI_DEVICE_EMULATION_MODE_GO_ON_QUEST = 1,
}
#[doc = " Emulation mode for applications developed on different devices"]
#[doc = " for determining if running in emulation mode at all test against != VRAPI_DEVICE_EMULATION_MODE_NONE"]
pub use self::ovrDeviceEmulationMode_ as ovrDeviceEmulationMode;
#[repr(u32)]
#[doc = " System configuration properties."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemProperty_ {
    VRAPI_SYS_PROP_DEVICE_TYPE = 0,
    VRAPI_SYS_PROP_MAX_FULLSPEED_FRAMEBUFFER_SAMPLES = 1,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_WIDE = 2,
    #[doc = " Physical width and height of the display in pixels."]
    VRAPI_SYS_PROP_DISPLAY_PIXELS_HIGH = 3,
    #[doc = " Returns the refresh rate of the display in cycles per second."]
    VRAPI_SYS_PROP_DISPLAY_REFRESH_RATE = 4,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_WIDTH = 5,
    #[doc = " With a display resolution of 2560x1440, the pixels at the center"]
    #[doc = " of each eye cover about 0.06 degrees of visual arc. To wrap a"]
    #[doc = " full 360 degrees, about 6000 pixels would be needed and about one"]
    #[doc = " quarter of that would be needed for ~90 degrees FOV. As such, Eye"]
    #[doc = " images with a resolution of 1536x1536 result in a good 1:1 mapping"]
    #[doc = " in the center, but they need mip-maps for off center pixels. To"]
    #[doc = " avoid the need for mip-maps and for significantly improved rendering"]
    #[doc = " performance this currently returns a conservative 1024x1024."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_TEXTURE_HEIGHT = 6,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_X = 7,
    #[doc = " This is a product of the lens distortion and the screen size,"]
    #[doc = " but there is no truly correct answer."]
    #[doc = " There is a tradeoff in resolution and coverage."]
    #[doc = " Too small of an FOV will leave unrendered pixels visible, but too"]
    #[doc = " large wastes resolution or fill rate.  It is unreasonable to"]
    #[doc = " increase it until the corners are completely covered, but we do"]
    #[doc = " want most of the outside edges completely covered."]
    #[doc = " Applications might choose to render a larger FOV when angular"]
    #[doc = " acceleration is high to reduce black pull in at the edges by"]
    #[doc = " the time warp."]
    #[doc = " Currently symmetric 90.0 degrees."]
    VRAPI_SYS_PROP_SUGGESTED_EYE_FOV_DEGREES_Y = 8,
    #[doc = " Path to the external SD card. On Android-M, this path is dynamic and can"]
    #[doc = " only be determined once the SD card is mounted. Returns an empty string if"]
    #[doc = " device does not support an ext sdcard or if running Android-M and the SD card"]
    #[doc = " is not mounted."]
    VRAPI_SYS_PROP_EXT_SDCARD_PATH = 9,
    #[doc = " Path to the external SD card. On Android-M, this path is dynamic and can"]
    #[doc = " only be determined once the SD card is mounted. Returns an empty string if"]
    #[doc = " device does not support an ext sdcard or if running Android-M and the SD card"]
    #[doc = " is not mounted."]
    VRAPI_SYS_PROP_DEVICE_REGION = 10,
    #[doc = " Video decoder limit for the device."]
    VRAPI_SYS_PROP_VIDEO_DECODER_LIMIT = 11,
    #[doc = " Video decoder limit for the device."]
    VRAPI_SYS_PROP_HEADSET_TYPE = 12,
    #[doc = " Returns an ovrHandedness enum indicating left or right hand."]
    VRAPI_SYS_PROP_DOMINANT_HAND = 15,
    #[doc = " Returns the number of display refresh rates supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_DISPLAY_REFRESH_RATES = 64,
    #[doc = " Returns an array of the supported display refresh rates."]
    VRAPI_SYS_PROP_SUPPORTED_DISPLAY_REFRESH_RATES = 65,
    #[doc = " Returns the number of swapchain texture formats supported by the system."]
    VRAPI_SYS_PROP_NUM_SUPPORTED_SWAPCHAIN_FORMATS = 66,
    #[doc = " Returns an array of the supported swapchain formats."]
    #[doc = " Formats are platform specific. For GLES, this is an array of"]
    #[doc = " GL internal formats."]
    VRAPI_SYS_PROP_SUPPORTED_SWAPCHAIN_FORMATS = 67,
    #[doc = " Returns VRAPI_TRUE if Multiview rendering support is available for this system,"]
    #[doc = " otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_MULTIVIEW_AVAILABLE = 128,
    #[doc = " Returns VRAPI_TRUE if submission of SRGB Layers is supported for this system,"]
    #[doc = " otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_SRGB_LAYER_SOURCE_AVAILABLE = 129,
    #[doc = " Returns VRAPI_TRUE if on-chip foveated rendering of swapchains is supported"]
    #[doc = " for this system, otherwise VRAPI_FALSE."]
    VRAPI_SYS_PROP_FOVEATION_AVAILABLE = 130,
}
#[doc = " System configuration properties."]
pub use self::ovrSystemProperty_ as ovrSystemProperty;
#[repr(u32)]
#[doc = " Configurable VrApi properties."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrProperty_ {
    VRAPI_FOVEATION_LEVEL = 15,
    VRAPI_REORIENT_HMD_ON_CONTROLLER_RECENTER = 17,
    VRAPI_LATCH_BACK_BUTTON_ENTIRE_FRAME = 18,
    VRAPI_BLOCK_REMOTE_BUTTONS_WHEN_NOT_EMULATING_HMT = 19,
    VRAPI_EAT_NATIVE_GAMEPAD_EVENTS = 20,
    VRAPI_ACTIVE_INPUT_DEVICE_ID = 24,
    VRAPI_DEVICE_EMULATION_MODE = 29,
}
#[doc = " Configurable VrApi properties."]
pub use self::ovrProperty_ as ovrProperty;
#[repr(u32)]
#[doc = " Specifies left or right handedness."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrHandedness_ {
    VRAPI_HAND_UNKNOWN = 0,
    VRAPI_HAND_LEFT = 1,
    VRAPI_HAND_RIGHT = 2,
}
#[doc = " Specifies left or right handedness."]
pub use self::ovrHandedness_ as ovrHandedness;
#[repr(u32)]
#[doc = " System status bits."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrSystemStatus_ {
    VRAPI_SYS_STATUS_DOCKED = 0,
    VRAPI_SYS_STATUS_MOUNTED = 1,
    VRAPI_SYS_STATUS_THROTTLED = 2,
    VRAPI_SYS_STATUS_RENDER_LATENCY_MILLISECONDS = 5,
    VRAPI_SYS_STATUS_TIMEWARP_LATENCY_MILLISECONDS = 6,
    VRAPI_SYS_STATUS_SCANOUT_LATENCY_MILLISECONDS = 7,
    VRAPI_SYS_STATUS_APP_FRAMES_PER_SECOND = 8,
    VRAPI_SYS_STATUS_SCREEN_TEARS_PER_SECOND = 9,
    VRAPI_SYS_STATUS_EARLY_FRAMES_PER_SECOND = 10,
    VRAPI_SYS_STATUS_STALE_FRAMES_PER_SECOND = 11,
    VRAPI_SYS_STATUS_RECENTER_COUNT = 13,
    VRAPI_SYS_STATUS_SYSTEM_UX_ACTIVE = 14,
    VRAPI_SYS_STATUS_USER_RECENTER_COUNT = 15,
    VRAPI_SYS_STATUS_FRONT_BUFFER_PROTECTED = 128,
    VRAPI_SYS_STATUS_FRONT_BUFFER_565 = 129,
    VRAPI_SYS_STATUS_FRONT_BUFFER_SRGB = 130,
}
#[doc = " System status bits."]
pub use self::ovrSystemStatus_ as ovrSystemStatus;
#[repr(i32)]
#[doc = " Possible results of initialization."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrInitializeStatus_ {
    VRAPI_INITIALIZE_SUCCESS = 0,
    VRAPI_INITIALIZE_UNKNOWN_ERROR = -1,
    VRAPI_INITIALIZE_PERMISSIONS_ERROR = -2,
    VRAPI_INITIALIZE_ALREADY_INITIALIZED = -3,
    VRAPI_INITIALIZE_SERVICE_CONNECTION_FAILED = -4,
}
#[doc = " Possible results of initialization."]
pub use self::ovrInitializeStatus_ as ovrInitializeStatus;
#[repr(u32)]
#[doc = " Supported graphics APIs."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrGraphicsAPI_ {
    VRAPI_GRAPHICS_API_TYPE_OPENGL_ES = 65536,
    VRAPI_GRAPHICS_API_OPENGL_ES_2 = 66048,
    VRAPI_GRAPHICS_API_OPENGL_ES_3 = 66304,
    VRAPI_GRAPHICS_API_TYPE_OPENGL = 131072,
    VRAPI_GRAPHICS_API_OPENGL_COMPAT = 131328,
    VRAPI_GRAPHICS_API_OPENGL_CORE_3 = 131840,
    VRAPI_GRAPHICS_API_OPENGL_CORE_4 = 132096,
    VRAPI_GRAPHICS_API_TYPE_VULKAN = 262144,
    VRAPI_GRAPHICS_API_VULKAN_1 = 262400,
}
#[doc = " Supported graphics APIs."]
pub use self::ovrGraphicsAPI_ as ovrGraphicsAPI;
#[doc = " Configuration details specified at initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInitParms_ {
    pub Type: ovrStructureType,
    pub ProductVersion: ::std::os::raw::c_int,
    pub MajorVersion: ::std::os::raw::c_int,
    pub MinorVersion: ::std::os::raw::c_int,
    pub PatchVersion: ::std::os::raw::c_int,
    pub GraphicsAPI: ovrGraphicsAPI,
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrInitParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInitParms_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInitParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInitParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).ProductVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(ProductVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MajorVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).MinorVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).PatchVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(PatchVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).GraphicsAPI as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(GraphicsAPI)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInitParms_>())).Java as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInitParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Configuration details specified at initialization."]
pub type ovrInitParms = ovrInitParms_;
#[repr(u32)]
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian systems."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrModeFlags_ {
    #[doc = " If set, warn and allow the app to continue at 30 FPS when throttling occurs."]
    #[doc = " If not set, display the level 2 error message which requires the user to undock."]
    VRAPI_MODE_FLAG_ALLOW_POWER_SAVE = 255,
    #[doc = " When an application moves backwards on the activity stack,"]
    #[doc = " the activity window it returns to is no longer flagged as fullscreen."]
    #[doc = " As a result, Android will also render the decor view, which wastes a"]
    #[doc = " significant amount of bandwidth."]
    #[doc = " By setting this flag, the fullscreen flag is reset on the window."]
    #[doc = " Unfortunately, this causes Android life cycle events that mess up"]
    #[doc = " several NativeActivity codebases like Stratum and UE4, so this"]
    #[doc = " flag should only be set for specific applications."]
    #[doc = " Use \"adb shell dumpsys SurfaceFlinger\" to verify"]
    #[doc = " that there is only one HWC next to the FB_TARGET."]
    VRAPI_MODE_FLAG_RESET_WINDOW_FULLSCREEN = 65280,
    #[doc = " The WindowSurface passed in is an ANativeWindow."]
    VRAPI_MODE_FLAG_NATIVE_WINDOW = 65536,
    #[doc = " Create the front buffer in TrustZone memory to allow protected DRM"]
    #[doc = " content to be rendered to the front buffer. This functionality"]
    #[doc = " requires the WindowSurface to be allocated from TimeWarp, via"]
    #[doc = " specifying the nativeWindow via VRAPI_MODE_FLAG_NATIVE_WINDOW."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_PROTECTED = 131072,
    #[doc = " Create a 16-bit 5:6:5 front buffer."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_565 = 262144,
    #[doc = " Create a front buffer using the sRGB color space."]
    VRAPI_MODE_FLAG_FRONT_BUFFER_SRGB = 524288,
    #[doc = " If set, indicates the OpenGL ES Context was created with EGL_CONTEXT_OPENGL_NO_ERROR_KHR attribute."]
    #[doc = " The same attribute would be applied when TimeWrap creates the shared context."]
    #[doc = " More information could be found at:"]
    #[doc = " https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_create_context_no_error.txt"]
    VRAPI_MODE_FLAG_CREATE_CONTEXT_NO_ERROR = 1048576,
}
#[doc = " \\note the first two flags use the first two bytes for backwards compatibility on little endian systems."]
pub use self::ovrModeFlags_ as ovrModeFlags;
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParms_ {
    pub Type: ovrStructureType,
    #[doc = " Combination of ovrModeFlags flags."]
    pub Flags: ::std::os::raw::c_uint,
    #[doc = " The Java VM is needed for the time warp thread to create a Java environment."]
    #[doc = " A Java environment is needed to access various system services. The thread"]
    #[doc = " that enters VR mode is responsible for attaching and detaching the Java"]
    #[doc = " environment. The Java Activity object is needed to get the windowManager,"]
    #[doc = " packageName, systemService, etc."]
    pub Java: ovrJava,
    #[doc = " Display to use for asynchronous time warp rendering."]
    #[doc = " Using EGL this is an EGLDisplay."]
    pub Display: ::std::os::raw::c_ulonglong,
    #[doc = " The window surface to use for asynchronous time warp rendering."]
    #[doc = " Using EGL this can be the EGLSurface created by the application for the ANativeWindow."]
    #[doc = " This should be the ANativeWIndow itself (requires VRAPI_MODE_FLAG_NATIVE_WINDOW)."]
    pub WindowSurface: ::std::os::raw::c_ulonglong,
    #[doc = " The resources from this context will be shared with the asynchronous time warp."]
    #[doc = " Using EGL this is an EGLContext."]
    pub ShareContext: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParms_>(),
        56usize,
        concat!("Size of: ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Java as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Java)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).Display as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(Display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).WindowSurface as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(WindowSurface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParms_>())).ShareContext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParms_),
            "::",
            stringify!(ShareContext)
        )
    );
}
#[doc = " Configuration details that stay constant between a vrapi_EnterVrMode()/vrapi_LeaveVrMode() pair."]
pub type ovrModeParms = ovrModeParms_;
#[doc = " Vulkan-specific mode paramaters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrModeParmsVulkan_ {
    pub ModeParms: ovrModeParms,
    #[doc = " For Vulkan, this should be the VkQueue created on the same Device as specified"]
    #[doc = " by vrapi_CreateSystemVulkan. An internally created VkFence object will be signaled"]
    #[doc = " by the completion of commands on the queue."]
    pub SynchronizationQueue: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ovrModeParmsVulkan_() {
    assert_eq!(
        ::std::mem::size_of::<ovrModeParmsVulkan_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrModeParmsVulkan_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrModeParmsVulkan_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).ModeParms as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(ModeParms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrModeParmsVulkan_>())).SynchronizationQueue as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrModeParmsVulkan_),
            "::",
            stringify!(SynchronizationQueue)
        )
    );
}
#[doc = " Vulkan-specific mode paramaters."]
pub type ovrModeParmsVulkan = ovrModeParmsVulkan_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrMobile {
    _unused: [u8; 0],
}
#[doc = " Full rigid body pose with first and second derivatives."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrRigidBodyPosef_ {
    pub Pose: ovrPosef,
    pub AngularVelocity: ovrVector3f,
    pub LinearVelocity: ovrVector3f,
    pub AngularAcceleration: ovrVector3f,
    pub LinearAcceleration: ovrVector3f,
    pub dead15: [::std::os::raw::c_uchar; 4usize],
    pub TimeInSeconds: f64,
    pub PredictionInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrRigidBodyPosef_() {
    assert_eq!(
        ::std::mem::size_of::<ovrRigidBodyPosef_>(),
        96usize,
        concat!("Size of: ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrRigidBodyPosef_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrRigidBodyPosef_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).Pose as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(Pose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularVelocity as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearVelocity as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearVelocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).AngularAcceleration as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(AngularAcceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).LinearAcceleration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(LinearAcceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).dead15 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(dead15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).TimeInSeconds as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrRigidBodyPosef_>())).PredictionInSeconds as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrRigidBodyPosef_),
            "::",
            stringify!(PredictionInSeconds)
        )
    );
}
#[doc = " Full rigid body pose with first and second derivatives."]
pub type ovrRigidBodyPosef = ovrRigidBodyPosef_;
#[repr(u32)]
#[doc = " Bit flags describing the current status of sensor tracking."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingStatus_ {
    VRAPI_TRACKING_STATUS_ORIENTATION_TRACKED = 1,
    VRAPI_TRACKING_STATUS_POSITION_TRACKED = 2,
    VRAPI_TRACKING_STATUS_ORIENTATION_VALID = 4,
    VRAPI_TRACKING_STATUS_POSITION_VALID = 8,
    VRAPI_TRACKING_STATUS_HMD_CONNECTED = 128,
}
#[doc = " Bit flags describing the current status of sensor tracking."]
pub use self::ovrTrackingStatus_ as ovrTrackingStatus;
#[doc = " Tracking state at a given absolute time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking2_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead17: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
    pub Eye: [ovrTracking2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTracking2___bindgen_ty_1 {
    pub ProjectionMatrix: ovrMatrix4f,
    pub ViewMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrTracking2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2___bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2___bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrTracking2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ProjectionMatrix as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ProjectionMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrTracking2___bindgen_ty_1>())).ViewMatrix as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2___bindgen_ty_1),
            "::",
            stringify!(ViewMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrTracking2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking2_>(),
        360usize,
        concat!("Size of: ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).dead17 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(dead17)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking2_>())).Eye as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking2_),
            "::",
            stringify!(Eye)
        )
    );
}
#[doc = " Tracking state at a given absolute time."]
pub type ovrTracking2 = ovrTracking2_;
#[doc = " Reports the status and pose of a motion tracker."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrTracking_ {
    #[doc = " Sensor status described by ovrTrackingStatus flags."]
    pub Status: ::std::os::raw::c_uint,
    pub dead19: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Predicted head configuration at the requested absolute time."]
    #[doc = " The pose describes the head orientation and center eye position."]
    pub HeadPose: ovrRigidBodyPosef,
}
#[test]
fn bindgen_test_layout_ovrTracking_() {
    assert_eq!(
        ::std::mem::size_of::<ovrTracking_>(),
        104usize,
        concat!("Size of: ", stringify!(ovrTracking_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrTracking_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrTracking_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).Status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).dead19 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(dead19)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrTracking_>())).HeadPose as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrTracking_),
            "::",
            stringify!(HeadPose)
        )
    );
}
#[doc = " Reports the status and pose of a motion tracker."]
pub type ovrTracking = ovrTracking_;
#[repr(u32)]
#[doc = " Specifies a reference frame for motion tracking data."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingTransform_ {
    VRAPI_TRACKING_TRANSFORM_IDENTITY = 0,
    VRAPI_TRACKING_TRANSFORM_CURRENT = 1,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_EYE_LEVEL = 2,
    VRAPI_TRACKING_TRANSFORM_SYSTEM_CENTER_FLOOR_LEVEL = 3,
}
#[doc = " Specifies a reference frame for motion tracking data."]
pub use self::ovrTrackingTransform_ as ovrTrackingTransform;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackingSpace_ {
    VRAPI_TRACKING_SPACE_LOCAL = 0,
    VRAPI_TRACKING_SPACE_LOCAL_FLOOR = 1,
    VRAPI_TRACKING_SPACE_LOCAL_TILTED = 2,
    VRAPI_TRACKING_SPACE_STAGE = 3,
    VRAPI_TRACKING_SPACE_LOCAL_FIXED_YAW = 7,
}
pub use self::ovrTrackingSpace_ as ovrTrackingSpace;
#[repr(i32)]
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTrackedDeviceTypeId_ {
    VRAPI_TRACKED_DEVICE_NONE = -1,
    VRAPI_TRACKED_DEVICE_HMD = 0,
    VRAPI_TRACKED_DEVICE_HAND_LEFT = 1,
    VRAPI_TRACKED_DEVICE_HAND_RIGHT = 2,
    VRAPI_NUM_TRACKED_DEVICES = 3,
}
#[doc = " Tracked device type id used to simplify interaction checks with Guardian"]
pub use self::ovrTrackedDeviceTypeId_ as ovrTrackedDeviceTypeId;
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrBoundaryTriggerResult_ {
    #[doc = " Closest point on the boundary surface."]
    pub ClosestPoint: ovrVector3f,
    #[doc = " Normal of the closest point on the boundary surface."]
    pub ClosestPointNormal: ovrVector3f,
    #[doc = " Distance to the closest guardian boundary surface."]
    pub ClosestDistance: f32,
    #[doc = " True if the boundary system is being triggered. Note that due to fade in/out effects this may not exactly match visibility."]
    pub IsTriggering: bool,
}
#[test]
fn bindgen_test_layout_ovrBoundaryTriggerResult_() {
    assert_eq!(
        ::std::mem::size_of::<ovrBoundaryTriggerResult_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrBoundaryTriggerResult_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrBoundaryTriggerResult_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPoint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestPointNormal as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestPointNormal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).ClosestDistance as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(ClosestDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrBoundaryTriggerResult_>())).IsTriggering as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrBoundaryTriggerResult_),
            "::",
            stringify!(IsTriggering)
        )
    );
}
#[doc = " Guardian boundary trigger state information based on a given tracked device type"]
pub type ovrBoundaryTriggerResult = ovrBoundaryTriggerResult_;
#[repr(u32)]
#[doc = " A texture type, such as 2D, array, or cubemap."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureType_ {
    VRAPI_TEXTURE_TYPE_2D = 0,
    VRAPI_TEXTURE_TYPE_2D_ARRAY = 2,
    VRAPI_TEXTURE_TYPE_CUBE = 3,
    VRAPI_TEXTURE_TYPE_MAX = 4,
}
#[doc = " A texture type, such as 2D, array, or cubemap."]
pub use self::ovrTextureType_ as ovrTextureType;
#[repr(u32)]
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTextureFormat_ {
    VRAPI_TEXTURE_FORMAT_NONE = 0,
    VRAPI_TEXTURE_FORMAT_565 = 1,
    VRAPI_TEXTURE_FORMAT_5551 = 2,
    VRAPI_TEXTURE_FORMAT_4444 = 3,
    VRAPI_TEXTURE_FORMAT_8888 = 4,
    VRAPI_TEXTURE_FORMAT_8888_sRGB = 5,
    VRAPI_TEXTURE_FORMAT_RGBA16F = 6,
    VRAPI_TEXTURE_FORMAT_DEPTH_16 = 7,
    VRAPI_TEXTURE_FORMAT_DEPTH_24 = 8,
    VRAPI_TEXTURE_FORMAT_DEPTH_24_STENCIL_8 = 9,
    VRAPI_TEXTURE_FORMAT_RG16 = 10,
}
#[doc = " A texture format."]
#[doc = " DEPRECATED in favor of passing platform-specific formats to vrapi_CreateTextureSwapChain3."]
pub use self::ovrTextureFormat_ as ovrTextureFormat;
#[repr(u32)]
#[doc = " Built-in convenience swapchains."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDefaultTextureSwapChain_ {
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN = 1,
    VRAPI_DEFAULT_TEXTURE_SWAPCHAIN_LOADING_ICON = 2,
}
#[doc = " Built-in convenience swapchains."]
pub use self::ovrDefaultTextureSwapChain_ as ovrDefaultTextureSwapChain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrTextureSwapChain {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " Per-frame configuration options."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameFlags_ {
    #[doc = " Flush the warp swap pipeline so the images show up immediately."]
    #[doc = " This is expensive and should only be used when an immediate transition"]
    #[doc = " is needed like displaying black when resetting the HMD orientation."]
    VRAPI_FRAME_FLAG_FLUSH = 2,
    #[doc = " This is the final frame. Do not accept any more frames after this."]
    VRAPI_FRAME_FLAG_FINAL = 4,
    #[doc = " Don't show the volume layer when set."]
    VRAPI_FRAME_FLAG_INHIBIT_VOLUME_LAYER = 64,
}
#[doc = " Per-frame configuration options."]
pub use self::ovrFrameFlags_ as ovrFrameFlags;
#[repr(u32)]
#[doc = " Per-frame configuration options that apply to a particular layer."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerFlags_ {
    #[doc = " NOTE: On Oculus standalone devices, chromatic aberration correction is enabled"]
    #[doc = " by default."]
    #[doc = " For Gear VR devices, this must be explicitly enabled by specifying the layer"]
    #[doc = " flag as it is a quality / performance trade off."]
    VRAPI_FRAME_LAYER_FLAG_CHROMATIC_ABERRATION_CORRECTION = 2,
    #[doc = " Used for some HUDs, but generally considered bad practice."]
    VRAPI_FRAME_LAYER_FLAG_FIXED_TO_VIEW = 4,
    #[doc = " Spin the layer - for loading icons"]
    VRAPI_FRAME_LAYER_FLAG_SPIN = 8,
    #[doc = " Clip fragments outside the layer's TextureRect"]
    VRAPI_FRAME_LAYER_FLAG_CLIP_TO_TEXTURE_RECT = 16,
    #[doc = " To get gamma correct sRGB filtering of the eye textures, the textures must be"]
    #[doc = " allocated with GL_SRGB8_ALPHA8 format and the window surface must be allocated"]
    #[doc = " with these attributes:"]
    #[doc = " EGL_GL_COLORSPACE_KHR,  EGL_GL_COLORSPACE_SRGB_KHR"]
    #[doc = ""]
    #[doc = " While we can reallocate textures easily enough, we can't change the window"]
    #[doc = " colorspace without relaunching the entire application, so if you want to"]
    #[doc = " be able to toggle between gamma correct and incorrect, you must allocate"]
    #[doc = " the framebuffer as sRGB, then inhibit that processing when using normal"]
    #[doc = " textures."]
    #[doc = ""]
    #[doc = " If the texture being read isn't an sRGB texture, the conversion"]
    #[doc = " on write must be inhibited or the colors are washed out."]
    #[doc = " This is necessary for using external images on an sRGB framebuffer."]
    VRAPI_FRAME_LAYER_FLAG_INHIBIT_SRGB_FRAMEBUFFER = 256,
    #[doc = " Allow Layer to use an expensive filtering mode. Only useful for 2D layers that are high"]
    #[doc = " resolution (e.g. a remote desktop layer), typically double or more the target resolution."]
    VRAPI_FRAME_LAYER_FLAG_FILTER_EXPENSIVE = 524288,
}
#[doc = " Per-frame configuration options that apply to a particular layer."]
pub use self::ovrFrameLayerFlags_ as ovrFrameLayerFlags;
#[repr(u32)]
#[doc = " The user's eye (left or right) that can see a layer."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerEye_ {
    VRAPI_FRAME_LAYER_EYE_LEFT = 0,
    VRAPI_FRAME_LAYER_EYE_RIGHT = 1,
    VRAPI_FRAME_LAYER_EYE_MAX = 2,
}
#[doc = " The user's eye (left or right) that can see a layer."]
pub use self::ovrFrameLayerEye_ as ovrFrameLayerEye;
#[repr(u32)]
#[doc = " Selects an operation for alpha blending two images."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerBlend_ {
    VRAPI_FRAME_LAYER_BLEND_ZERO = 0,
    VRAPI_FRAME_LAYER_BLEND_ONE = 1,
    VRAPI_FRAME_LAYER_BLEND_SRC_ALPHA = 2,
    #[doc = " enum 3 used to be VRAPI_FRAME_LAYER_BLEND_DST_ALPHA."]
    #[doc = " enum 4 used to be VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_DST_ALPHA."]
    VRAPI_FRAME_LAYER_BLEND_ONE_MINUS_SRC_ALPHA = 5,
}
#[doc = " Selects an operation for alpha blending two images."]
pub use self::ovrFrameLayerBlend_ as ovrFrameLayerBlend;
#[repr(u32)]
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrExtraLatencyMode_ {
    VRAPI_EXTRA_LATENCY_MODE_OFF = 0,
    VRAPI_EXTRA_LATENCY_MODE_ON = 1,
    VRAPI_EXTRA_LATENCY_MODE_DYNAMIC = 2,
}
#[doc = " Extra latency mode pipelines app CPU work a frame ahead of VR composition."]
pub use self::ovrExtraLatencyMode_ as ovrExtraLatencyMode;
#[repr(u32)]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameLayerType_ {
    VRAPI_FRAME_LAYER_TYPE_MAX = 4,
}
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub use self::ovrFrameLayerType_ as ovrFrameLayerType;
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayerTexture_ {
    #[doc = " Because OpenGL ES does not support clampToBorder, it is the"]
    #[doc = " application's responsibility to make sure that all mip levels"]
    #[doc = " of the primary eye texture have a black border that will show"]
    #[doc = " up when time warp pushes the texture partially off screen."]
    pub ColorTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " \\deprecated The depth texture is optional for positional time warp."]
    pub DepthTextureSwapChain: *mut ovrTextureSwapChain,
    #[doc = " Index to the texture from the set that should be displayed."]
    pub TextureSwapChainIndex: ::std::os::raw::c_int,
    #[doc = " Points on the screen are mapped by a distortion correction"]
    #[doc = " function into ( TanX, TanY, -1, 1 ) vectors that are transformed"]
    #[doc = " by this matrix to get ( S, T, Q, _ ) vectors that are looked"]
    #[doc = " up with texture2dproj() to get texels."]
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    #[doc = " Only texels within this range should be drawn."]
    #[doc = " This is a sub-rectangle of the [(0,0)-(1,1)] texture coordinate range."]
    pub TextureRect: ovrRectf,
    pub dead22: [::std::os::raw::c_uchar; 4usize],
    #[doc = " The tracking state for which ModelViewMatrix is correct."]
    #[doc = " It is ok to update the orientation for each eye, which"]
    #[doc = " can help minimize black edge pull-in, but the position"]
    #[doc = " must remain the same for both eyes, or the position would"]
    #[doc = " seem to judder \"backwards in time\" if a frame is dropped."]
    pub HeadPose: ovrRigidBodyPosef,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_ovrFrameLayerTexture_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayerTexture_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayerTexture_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayerTexture_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).ColorTextureSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(ColorTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).DepthTextureSwapChain as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(DepthTextureSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureSwapChainIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureSwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).TextureRect as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).dead22 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(dead22)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).HeadPose as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayerTexture_>())).Pad as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayerTexture_),
            "::",
            stringify!(Pad)
        )
    );
}
#[doc = " A compositor layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayerTexture = ovrFrameLayerTexture_;
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameLayer_ {
    #[doc = " Image used for each eye."]
    pub Textures: [ovrFrameLayerTexture; 2usize],
    #[doc = " Speed and scale of rotation when VRAPI_FRAME_LAYER_FLAG_SPIN is set in ovrFrameLayer::Flags"]
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Color scale for this layer (including alpha)"]
    pub ColorScale: f32,
    pub dead25: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layer blend function."]
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " Combination of ovrFrameLayerFlags flags."]
    pub Flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrFrameLayer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameLayer_>(),
        448usize,
        concat!("Size of: ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameLayer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameLayer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Textures as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinSpeed as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SpinScale as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).ColorScale as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).dead25 as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(dead25)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).SrcBlend as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).DstBlend as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameLayer_>())).Flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameLayer_),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " Per-frame state of a compositor layer."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameLayer = ovrFrameLayer_;
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrPerformanceParms_ {
    #[doc = " These are fixed clock levels in the range [0, 3]."]
    pub CpuLevel: ::std::os::raw::c_int,
    pub GpuLevel: ::std::os::raw::c_int,
    #[doc = " These threads will get SCHED_FIFO."]
    pub MainThreadTid: ::std::os::raw::c_int,
    pub RenderThreadTid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrPerformanceParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrPerformanceParms_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrPerformanceParms_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrPerformanceParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).CpuLevel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(CpuLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrPerformanceParms_>())).GpuLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(GpuLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).MainThreadTid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(MainThreadTid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrPerformanceParms_>())).RenderThreadTid as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrPerformanceParms_),
            "::",
            stringify!(RenderThreadTid)
        )
    );
}
#[doc = " Configuration parameters that affect system performance and scheduling behavior."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrPerformanceParms = ovrPerformanceParms_;
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrFrameParms_ {
    pub Type: ovrStructureType,
    pub dead29: [::std::os::raw::c_uchar; 4usize],
    #[doc = " Layers composited in the time warp."]
    pub Layers: [ovrFrameLayer; 4usize],
    pub LayerCount: ::std::os::raw::c_int,
    #[doc = " Combination of ovrFrameFlags flags."]
    pub Flags: ::std::os::raw::c_int,
    #[doc = " Application controlled frame index that uniquely identifies this particular frame."]
    #[doc = " This must be the same frame index that was passed to vrapi_GetPredictedDisplayTime()"]
    #[doc = " when synthesis of this frame started."]
    pub FrameIndex: ::std::os::raw::c_longlong,
    #[doc = " WarpSwap will not return until at least this many V-syncs have"]
    #[doc = " passed since the previous WarpSwap returned."]
    #[doc = " Setting to 2 will reduce power consumption and may make animation"]
    #[doc = " more regular for applications that can't hold full frame rate."]
    pub SwapInterval: ::std::os::raw::c_int,
    #[doc = " Latency Mode."]
    pub ExtraLatencyMode: ovrExtraLatencyMode,
    #[doc = " \\unused parameter."]
    pub Reserved: ovrMatrix4f,
    #[doc = " \\unused parameter."]
    pub Reserved1: *mut ::std::os::raw::c_void,
    #[doc = " CPU/GPU performance parameters."]
    pub PerformanceParms: ovrPerformanceParms,
    #[doc = " For handling HMD events and power level state changes."]
    pub Java: ovrJava,
}
#[test]
fn bindgen_test_layout_ovrFrameParms_() {
    assert_eq!(
        ::std::mem::size_of::<ovrFrameParms_>(),
        1936usize,
        concat!("Size of: ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrFrameParms_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrFrameParms_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).dead29 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(dead29)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Layers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).LayerCount as *const _ as usize },
        1800usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Flags as *const _ as usize },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).FrameIndex as *const _ as usize },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).SwapInterval as *const _ as usize },
        1816usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).ExtraLatencyMode as *const _ as usize },
        1820usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(ExtraLatencyMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved as *const _ as usize },
        1824usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Reserved1 as *const _ as usize },
        1888usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).PerformanceParms as *const _ as usize },
        1896usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(PerformanceParms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrFrameParms_>())).Java as *const _ as usize },
        1912usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrFrameParms_),
            "::",
            stringify!(Java)
        )
    );
}
#[doc = " Per-frame details."]
#[doc = " \\deprecated The vrapi_SubmitFrame2 path with flexible layer types"]
#[doc = " should be used instead."]
pub type ovrFrameParms = ovrFrameParms_;
#[repr(u32)]
#[doc = " A layer type."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrLayerType2_ {
    VRAPI_LAYER_TYPE_PROJECTION2 = 1,
    VRAPI_LAYER_TYPE_CYLINDER2 = 3,
    VRAPI_LAYER_TYPE_CUBE2 = 4,
    VRAPI_LAYER_TYPE_EQUIRECT2 = 5,
    VRAPI_LAYER_TYPE_LOADING_ICON2 = 6,
    VRAPI_LAYER_TYPE_FISHEYE2 = 7,
}
#[doc = " A layer type."]
pub use self::ovrLayerType2_ as ovrLayerType2;
#[doc = " Properties shared by any type of layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerHeader2_ {
    pub Type: ovrLayerType2,
    pub Flags: u32,
    pub ColorScale: ovrVector4f,
    pub SrcBlend: ovrFrameLayerBlend,
    pub DstBlend: ovrFrameLayerBlend,
    #[doc = " \\unused parameter."]
    pub Reserved: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ovrLayerHeader2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerHeader2_>(),
        40usize,
        concat!("Size of: ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerHeader2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerHeader2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).ColorScale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(ColorScale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).SrcBlend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(SrcBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).DstBlend as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(DstBlend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerHeader2_>())).Reserved as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerHeader2_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Properties shared by any type of layer."]
pub type ovrLayerHeader2 = ovrLayerHeader2_;
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerProjection2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_PROJECTION2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerProjection2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerProjection2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerProjection2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).ColorSwapChain
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).SwapChainIndex
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerProjection2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerProjection2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerProjection2_>(),
        328usize,
        concat!("Size of: ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerProjection2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerProjection2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerProjection2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerProjection2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerProjection2 provides support for a typical world view layer."]
#[doc = " \\note Any layer textures that are dynamic must be triple buffered."]
pub type ovrLayerProjection2 = ovrLayerProjection2_;
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " comes from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCylinder2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CYLINDER2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerCylinder2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCylinder2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        160usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TexCoordsFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCylinder2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCylinder2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCylinder2_>(),
        456usize,
        concat!("Size of: ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCylinder2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCylinder2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCylinder2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCylinder2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCylinder2 provides support for a single 2D texture projected onto a cylinder shape."]
#[doc = ""]
#[doc = " For Cylinder, the vertex coordinates will be transformed as if the texture type was CUBE."]
#[doc = " Additionally, the interpolated vec3 will be remapped to vec2 by a direction-to-hemicyl mapping."]
#[doc = " This mapping is currently hard-coded to 180 degrees around and 60 degrees vertical FOV."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " comes from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerCylinder2 = ovrLayerCylinder2_;
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerCube2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_CUBE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Offset: ovrVector3f,
    pub Textures: [ovrLayerCube2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerCube2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a cube target (VRAPI_TEXTURE_TYPE_CUBE)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerCube2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2___bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerCube2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerCube2_>(),
        248usize,
        concat!("Size of: ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerCube2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerCube2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerCube2_>())).TexCoordsFromTanAngles as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Offset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerCube2_>())).Textures as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerCube2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerCube2 provides support for a single timewarped cubemap at infinity"]
#[doc = " with optional Offset vector (provided in normalized [-1.0,1.0] space)."]
#[doc = ""]
#[doc = " Cube maps are an omni-directional layer source that are directly supported"]
#[doc = " by the graphics hardware. The nature of the cube map definition results in"]
#[doc = " higher resolution (in pixels per solid angle) at the corners and edges of"]
#[doc = " the cube and lower resolution at the center of each face. While the cube map"]
#[doc = " does have variability in sample density, the variability is spread symmetrically"]
#[doc = " around the sphere."]
#[doc = ""]
#[doc = " Sometimes it is valuable to have an omni-directional format that has a"]
#[doc = " directional bias where quality and sample density is better in a particular"]
#[doc = " direction or over a particular region. If we changed the cube map sampling"]
#[doc = ""]
#[doc = " from:"]
#[doc = "   color = texture( cubeLayerSampler, direction );"]
#[doc = " to:"]
#[doc = "   color = texture( cubeLayerSampler, normalize( direction ) + offset );"]
#[doc = ""]
#[doc = " we can provide a remapping of the cube map sample distribution such that"]
#[doc = " samples in the \"offset\" direction map to a smaller region of the cube map"]
#[doc = " (and are thus higher resolution)."]
#[doc = ""]
#[doc = " A normal high resolution cube map can be resampled using the inverse of this"]
#[doc = " mapping to retain high resolution for one direction while signficantly reducing"]
#[doc = " the required size of the cube map."]
#[doc = ""]
pub type ovrLayerCube2 = ovrLayerCube2_;
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a direction-to-equirect"]
#[doc = " mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " come from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerEquirect2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_EQUIRECT2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub TexCoordsFromTanAngles: ovrMatrix4f,
    pub Textures: [ovrLayerEquirect2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerEquirect2___bindgen_ty_1 {
    #[doc = " Texture type used to create the swapchain must be a 2D target (VRAPI_TEXTURE_TYPE_2D_*)."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub TextureRect: ovrRectf,
    #[doc = " \\note textureMatrix is set up like the following:"]
    #[doc = "\tsx,  0, tx, 0"]
    #[doc = "\t0,  sy, ty, 0"]
    #[doc = "\t0,   0,  1, 0"]
    #[doc = "\t0,   0,  0, 1"]
    #[doc = " since we do not need z coord for mapping to 2d texture."]
    pub TextureMatrix: ovrMatrix4f,
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        96usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2___bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerEquirect2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerEquirect2_>(),
        392usize,
        concat!("Size of: ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerEquirect2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerEquirect2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerEquirect2_>())).TexCoordsFromTanAngles as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(TexCoordsFromTanAngles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerEquirect2_>())).Textures as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerEquirect2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " ovrLayerEquirect2 provides support for a single Equirectangular texture at infinity."]
#[doc = ""]
#[doc = " For Equirectangular, the vertex coordinates will be transformed as if the texture type was CUBE,"]
#[doc = " and in the fragment shader, the interpolated vec3 will be remapped to vec2 by a direction-to-equirect"]
#[doc = " mapping."]
#[doc = ""]
#[doc = " After the mapping to 2D, an optional textureMatrix is applied. In the monoscopic case, the matrix"]
#[doc = " will typically be the identity matrix (ie no scale, bias). In the stereo case, when the image source"]
#[doc = " come from a single image, the transform is necessary to map the [0.0,1.0] output to a different"]
#[doc = " (sub)rect."]
#[doc = ""]
#[doc = " Regardless of how the textureMatrix transforms the vec2 output of the equirect transform, each"]
#[doc = " TextureRect clamps the resulting texture coordinates so that no coordinates are beyond the specified"]
#[doc = " extents. No guarantees are made about whether fragments will be shaded outside the rect, so it is"]
#[doc = " important that the subrect have a transparent border."]
#[doc = ""]
pub type ovrLayerEquirect2 = ovrLayerEquirect2_;
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerLoadingIcon2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_LOADING_ICON2."]
    pub Header: ovrLayerHeader2,
    pub SpinSpeed: f32,
    pub SpinScale: f32,
    #[doc = " Only monoscopic texture supported for spinning layer."]
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ovrLayerLoadingIcon2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerLoadingIcon2_>(),
        64usize,
        concat!("Size of: ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerLoadingIcon2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerLoadingIcon2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinSpeed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinSpeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SpinScale as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SpinScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).ColorSwapChain as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerLoadingIcon2_>())).SwapChainIndex as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerLoadingIcon2_),
            "::",
            stringify!(SwapChainIndex)
        )
    );
}
#[doc = " ovrLayerLoadingIcon2 provides support for a monoscopic spinning layer."]
#[doc = ""]
pub type ovrLayerLoadingIcon2 = ovrLayerLoadingIcon2_;
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for stereo."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ovrLayerFishEye2_ {
    #[doc = " Header.Type must be VRAPI_LAYER_TYPE_FISHEYE2."]
    pub Header: ovrLayerHeader2,
    pub HeadPose: ovrRigidBodyPosef,
    pub Textures: [ovrLayerFishEye2___bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrLayerFishEye2___bindgen_ty_1 {
    pub ColorSwapChain: *mut ovrTextureSwapChain,
    pub SwapChainIndex: ::std::os::raw::c_int,
    pub LensFromTanAngles: ovrMatrix4f,
    pub TextureRect: ovrRectf,
    pub TextureMatrix: ovrMatrix4f,
    pub Distortion: ovrVector4f,
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2___bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        176usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2___bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2___bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).ColorSwapChain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(ColorSwapChain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).SwapChainIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(SwapChainIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).LensFromTanAngles
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(LensFromTanAngles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureRect as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).TextureMatrix as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(TextureMatrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrLayerFishEye2___bindgen_ty_1>())).Distortion as *const _
                as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2___bindgen_ty_1),
            "::",
            stringify!(Distortion)
        )
    );
}
#[test]
fn bindgen_test_layout_ovrLayerFishEye2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayerFishEye2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayerFishEye2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayerFishEye2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).HeadPose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(HeadPose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayerFishEye2_>())).Textures as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayerFishEye2_),
            "::",
            stringify!(Textures)
        )
    );
}
#[doc = " An \"equiangular fisheye\" or \"f-theta\" lens can be used to capture photos or video"]
#[doc = " of around 180 degrees without stitching."]
#[doc = ""]
#[doc = " The cameras probably aren't exactly vertical, so a transformation may need to be applied"]
#[doc = " before performing the fisheye calculation."]
#[doc = " A stereo fisheye camera rig will usually have slight misalignments between the two"]
#[doc = " cameras, so they need independent transformations."]
#[doc = ""]
#[doc = " Once in lens space, the ray is transformed into an ideal fisheye projection, where the"]
#[doc = " 180 degree hemisphere is mapped to a -1 to 1 2D space."]
#[doc = ""]
#[doc = " From there it can be mapped into actual texture coordinates, possibly two to an image for stereo."]
#[doc = ""]
pub type ovrLayerFishEye2 = ovrLayerFishEye2_;
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ovrLayer_Union2_ {
    pub Header: ovrLayerHeader2,
    pub Projection: ovrLayerProjection2,
    pub Cylinder: ovrLayerCylinder2,
    pub Cube: ovrLayerCube2,
    pub Equirect: ovrLayerEquirect2,
    pub LoadingIcon: ovrLayerLoadingIcon2,
    pub FishEye: ovrLayerFishEye2,
    _bindgen_union_align: [u64; 61usize],
}
#[test]
fn bindgen_test_layout_ovrLayer_Union2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrLayer_Union2_>(),
        488usize,
        concat!("Size of: ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrLayer_Union2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrLayer_Union2_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Projection as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Projection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cylinder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cylinder)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Cube as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Cube)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).Equirect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(Equirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).LoadingIcon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(LoadingIcon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrLayer_Union2_>())).FishEye as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrLayer_Union2_),
            "::",
            stringify!(FishEye)
        )
    );
}
#[doc = " Union that combines ovrLayer types in a way that allows them"]
#[doc = " to be used in a polymorphic way."]
pub type ovrLayer_Union2 = ovrLayer_Union2_;
#[doc = " Parameters for frame submission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrSubmitFrameDescription2_ {
    pub Flags: u32,
    pub SwapInterval: u32,
    pub FrameIndex: u64,
    pub DisplayTime: f64,
    #[doc = " \\unused parameter."]
    pub Pad: [::std::os::raw::c_uchar; 8usize],
    pub LayerCount: u32,
    pub Layers: *const *const ovrLayerHeader2,
}
#[test]
fn bindgen_test_layout_ovrSubmitFrameDescription2_() {
    assert_eq!(
        ::std::mem::size_of::<ovrSubmitFrameDescription2_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrSubmitFrameDescription2_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrSubmitFrameDescription2_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).SwapInterval as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(SwapInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).FrameIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(FrameIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).DisplayTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(DisplayTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Pad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).LayerCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(LayerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrSubmitFrameDescription2_>())).Layers as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrSubmitFrameDescription2_),
            "::",
            stringify!(Layers)
        )
    );
}
#[doc = " Parameters for frame submission."]
pub type ovrSubmitFrameDescription2 = ovrSubmitFrameDescription2_;
#[repr(u32)]
#[doc = " Identifies a VR-related application thread."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrPerfThreadType_ {
    VRAPI_PERF_THREAD_TYPE_MAIN = 0,
    VRAPI_PERF_THREAD_TYPE_RENDERER = 1,
}
#[doc = " Identifies a VR-related application thread."]
pub use self::ovrPerfThreadType_ as ovrPerfThreadType;
extern "C" {
    #[doc = " Returns the version + compile time stamp as a string."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetVersionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns global, absolute high-resolution time in seconds. This is the same value"]
    #[doc = " as used in sensor messages and on Android also the same as Java's system.nanoTime(),"]
    #[doc = " which is what the Choreographer V-sync timestamp is based on."]
    #[doc = " \\warning Do not use this time as a seed for simulations, animations or other logic."]
    #[doc = " An animation, for instance, should not be updated based on the \"real time\" the"]
    #[doc = " animation code is executed. Instead, an animation should be updated based on the"]
    #[doc = " time it will be displayed. Using the \"real time\" will introduce intra-frame motion"]
    #[doc = " judder when the code is not executed at a consistent point in time every frame."]
    #[doc = " In other words, for simulations, animations and other logic use the time returned"]
    #[doc = " by vrapi_GetPredictedDisplayTime()."]
    #[doc = " Can be called any time from any thread."]
    pub fn vrapi_GetTimeInSeconds() -> f64;
}
extern "C" {
    #[doc = " Initializes the API for application use."]
    #[doc = " This is lightweight and does not create any threads."]
    #[doc = " This is typically called from onCreate() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    #[doc = " Returns a non-zero value from ovrInitializeStatus on error."]
    pub fn vrapi_Initialize(initParms: *const ovrInitParms) -> ovrInitializeStatus;
}
extern "C" {
    #[doc = " Shuts down the API on application exit."]
    #[doc = " This is typically called from onDestroy() or shortly thereafter."]
    #[doc = " Can be called from any thread."]
    pub fn vrapi_Shutdown();
}
extern "C" {
    #[doc = " Returns a VrApi property."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_SetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn vrapi_SetPropertyFloat(java: *const ovrJava, propType: ovrProperty, floatVal: f32);
}
extern "C" {
    #[doc = " Returns false if the property cannot be read."]
    pub fn vrapi_GetPropertyInt(
        java: *const ovrJava,
        propType: ovrProperty,
        intVal: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns a system property. These are constants for a particular device."]
    #[doc = " These functions can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemPropertyInt(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyFloat(java: *const ovrJava, propType: ovrSystemProperty) -> f32;
}
extern "C" {
    #[doc = " Returns the number of elements written to values array."]
    pub fn vrapi_GetSystemPropertyFloatArray(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut f32,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemPropertyInt64Array(
        java: *const ovrJava,
        propType: ovrSystemProperty,
        values: *mut i64,
        numArrayValues: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The return memory is guaranteed to be valid until the next call to vrapi_GetSystemPropertyString."]
    pub fn vrapi_GetSystemPropertyString(
        java: *const ovrJava,
        propType: ovrSystemProperty,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a system status. These are variables that may change at run-time."]
    #[doc = " This function can be called any time from any thread once the VrApi is initialized."]
    pub fn vrapi_GetSystemStatusInt(
        java: *const ovrJava,
        statusType: ovrSystemStatus,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vrapi_GetSystemStatusFloat(java: *const ovrJava, statusType: ovrSystemStatus) -> f32;
}
extern "C" {
    #[doc = " Starts up the time warp, V-sync tracking, sensor reading, clock locking,"]
    #[doc = " thread scheduling, and sets video options. The parms are copied, and are"]
    #[doc = " not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This should be called after vrapi_Initialize(), when the app is both"]
    #[doc = " resumed and has a valid window surface (ANativeWindow)."]
    #[doc = ""]
    #[doc = " On Android, an application cannot just allocate a new window surface"]
    #[doc = " and render to it. Android allocates and manages the window surface and"]
    #[doc = " (after the fact) notifies the application of the state of affairs through"]
    #[doc = " life cycle events (surfaceCreated / surfaceChanged / surfaceDestroyed)."]
    #[doc = " The application (or 3rd party engine) typically handles these events."]
    #[doc = " Since the VrApi cannot just allocate a new window surface, and the VrApi"]
    #[doc = " does not handle the life cycle events, the VrApi somehow has to take over"]
    #[doc = " ownership of the Android surface from the application. To allow this, the"]
    #[doc = " application can explicitly pass the EGLDisplay, EGLContext and EGLSurface"]
    #[doc = " or ANativeWindow to vrapi_EnterVrMode(). The EGLDisplay and EGLContext are"]
    #[doc = " used to create a shared context used by the background time warp thread."]
    #[doc = ""]
    #[doc = " If, however, the application does not explicitly pass in these objects, then"]
    #[doc = " vrapi_EnterVrMode() *must* be called from a thread with an OpenGL ES context"]
    #[doc = " current on the Android window surface. The context of the calling thread is"]
    #[doc = " then used to match the version and config for the context used by the background"]
    #[doc = " time warp thread. The time warp will also hijack the Android window surface"]
    #[doc = " from the context that is current on the calling thread. On return, the context"]
    #[doc = " from the calling thread will be current on an invisible pbuffer, because the"]
    #[doc = " time warp takes ownership of the Android window surface. Note that this requires"]
    #[doc = " the config used by the calling thread to have an EGL_SURFACE_TYPE with EGL_PBUFFER_BIT."]
    #[doc = ""]
    #[doc = " New applications must always explicitly pass in the EGLDisplay, EGLContext"]
    #[doc = " and ANativeWindow, otherwise vrapi_EnterVrMode will fail."]
    #[doc = ""]
    #[doc = " This function will return NULL when entering VR mode failed because the ANativeWindow"]
    #[doc = " was not valid. If the ANativeWindow's buffer queue is abandoned"]
    #[doc = " (\"BufferQueueProducer: BufferQueue has been abandoned\"), then the app can wait for a"]
    #[doc = " new ANativeWindow (through SurfaceCreated). If another API is already connected to"]
    #[doc = " the ANativeWindow (\"BufferQueueProducer: already connected\"), then the app has to first"]
    #[doc = " disconnect whatever is connected to the ANativeWindow (typically an EGLSurface)."]
    pub fn vrapi_EnterVrMode(parms: *const ovrModeParms) -> *mut ovrMobile;
}
extern "C" {
    #[doc = " Shut everything down for window destruction or when the activity is paused."]
    #[doc = " The ovrMobile object is freed by this function."]
    #[doc = ""]
    #[doc = " Must be called from the same thread that called vrapi_EnterVrMode(). If the"]
    #[doc = " application did not explicitly pass in the Android window surface, then this"]
    #[doc = " thread *must* have the same OpenGL ES context that was current on the Android"]
    #[doc = " window surface before calling vrapi_EnterVrMode(). By calling this function,"]
    #[doc = " the time warp gives up ownership of the Android window surface, and on return,"]
    #[doc = " the context from the calling thread will be current again on the Android window"]
    #[doc = " surface."]
    pub fn vrapi_LeaveVrMode(ovr: *mut ovrMobile);
}
extern "C" {
    #[doc = " Returns a predicted absolute system time in seconds at which the next set"]
    #[doc = " of eye images will be displayed."]
    #[doc = ""]
    #[doc = " The predicted time is the middle of the time period during which the new"]
    #[doc = " eye images will be displayed. The number of frames predicted ahead depends"]
    #[doc = " on the pipeline depth of the engine and the minumum number of V-syncs in"]
    #[doc = " between eye image rendering. The better the prediction, the less black will"]
    #[doc = " be pulled in at the edges by the time warp."]
    #[doc = ""]
    #[doc = " The frameIndex is an application controlled number that uniquely identifies"]
    #[doc = " the new set of eye images for which synthesis is about to start. This same"]
    #[doc = " frameIndex must be passed to vrapi_SubmitFrame() when the new eye images are"]
    #[doc = " submitted to the time warp. The frameIndex is expected to be incremented"]
    #[doc = " once every frame before calling this function."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedDisplayTime(
        ovr: *mut ovrMobile,
        frameIndex: ::std::os::raw::c_longlong,
    ) -> f64;
}
extern "C" {
    #[doc = " Returns the predicted sensor state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = ""]
    #[doc = " Can be called from any thread while in VR mode."]
    pub fn vrapi_GetPredictedTracking2(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking2;
}
extern "C" {
    pub fn vrapi_GetPredictedTracking(ovr: *mut ovrMobile, absTimeInSeconds: f64) -> ovrTracking;
}
extern "C" {
    pub fn vrapi_RecenterPose(ovr: *mut ovrMobile);
}
extern "C" {
    pub fn vrapi_GetTrackingTransform(
        ovr: *mut ovrMobile,
        whichTransform: ovrTrackingTransform,
    ) -> ovrPosef;
}
extern "C" {
    pub fn vrapi_SetTrackingTransform(ovr: *mut ovrMobile, pose: ovrPosef);
}
extern "C" {
    #[doc = " Returns the current tracking space"]
    pub fn vrapi_GetTrackingSpace(ovr: *mut ovrMobile) -> ovrTrackingSpace;
}
extern "C" {
    #[doc = " Set the tracking space. There are currently two options:"]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL (default)"]
    #[doc = "         The local tracking space's origin is at the nominal head position"]
    #[doc = "         with +y up, and -z forward. This space is volatile and will change"]
    #[doc = "         when system recentering occurs."]
    #[doc = "   * VRAPI_TRACKING_SPACE_LOCAL_FLOOR"]
    #[doc = "         The local floor tracking space is the same as the local tracking"]
    #[doc = "         space, except its origin is translated down to the floor. The local"]
    #[doc = "         floor space differs from the local space only in its y translation."]
    #[doc = "         This space is volatile and will change when system recentering occurs."]
    pub fn vrapi_SetTrackingSpace(ovr: *mut ovrMobile, whichSpace: ovrTrackingSpace) -> ovrResult;
}
extern "C" {
    #[doc = " Returns pose of the requested space relative to the current space."]
    #[doc = " The returned value is not affected by the current tracking transform."]
    pub fn vrapi_LocateTrackingSpace(ovr: *mut ovrMobile, target: ovrTrackingSpace) -> ovrPosef;
}
extern "C" {
    #[doc = " Get the geometry of the Guardian System as a list of points that define the outer boundary space."]
    #[doc = " You can choose to get just the number of points by passing in a null value for points or"]
    #[doc = " by passing in a pointsCountInput size of 0.  Otherwise pointsCountInput will be used to fetch"]
    #[doc = " as many points as possible from the Guardian points data.  If the input size exceeds the"]
    #[doc = " number of points that are currently stored off we only copy up to the number of points that we"]
    #[doc = " have and pointsCountOutput will return the number of copied points"]
    pub fn vrapi_GetBoundaryGeometry(
        ovr: *mut ovrMobile,
        pointsCountInput: u32,
        pointsCountOutput: *mut u32,
        points: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Gets the dimension of the Oriented Bounding box for the Guardian System.  This is the largest"]
    #[doc = " fit rectangle within the Guardian System boundary geometry. The pose value contains the forward facing"]
    #[doc = " direction as well as the translation for the oriented box.  The scale return value returns a"]
    #[doc = " scalar value for the width, height, and depth of the box.  These values are half the actual size"]
    #[doc = " as they are scalars and in meters.\""]
    pub fn vrapi_GetBoundaryOrientedBoundingBox(
        ovr: *mut ovrMobile,
        pose: *mut ovrPosef,
        scale: *mut ovrVector3f,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of a 3D point against the Guardian System Boundary and returns whether or not a"]
    #[doc = " given point is inside or outside of the boundary.  If a more detailed set of boundary"]
    #[doc = " trigger information is requested a ovrBoundaryTriggerResult may be passed in.  However null may"]
    #[doc = " also be passed in to just return whether a point is inside the boundary or not."]
    pub fn vrapi_TestPointIsInBoundary(
        ovr: *mut ovrMobile,
        point: ovrVector3f,
        pointInsideBoundary: *mut bool,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Tests collision/proximity of position tracked devices (e.g. HMD and/or Controllers) against the"]
    #[doc = " Guardian System boundary. This function returns an ovrGuardianTriggerResult which contains information"]
    #[doc = " such as distance and closest point based on collision/proximity test"]
    pub fn vrapi_GetBoundaryTriggerState(
        ovr: *mut ovrMobile,
        deviceId: ovrTrackedDeviceTypeId,
        result: *mut ovrBoundaryTriggerResult,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Used to force Guardian System mesh visibility to true.  Forcing to false will set the Guardian"]
    #[doc = " System back to normal operation."]
    pub fn vrapi_RequestBoundaryVisible(ovr: *mut ovrMobile, visible: bool) -> ovrResult;
}
extern "C" {
    #[doc = " Used to access whether or not the Guardian System is visible or not"]
    pub fn vrapi_GetBoundaryVisible(ovr: *mut ovrMobile, visible: *mut bool) -> ovrResult;
}
extern "C" {
    #[doc = " Create a texture swap chain that can be passed to vrapi_SubmitFrame."]
    #[doc = " Must be called from a thread with a valid OpenGL ES context current."]
    #[doc = ""]
    #[doc = " 'bufferCount' used to be a bool that selected either a single texture index"]
    #[doc = " or a triple buffered index, but the new entry point vrapi_CreateTextureSwapChain2,"]
    #[doc = " allows up to 16 buffers to be allocated, which is useful for maintaining a"]
    #[doc = " deep video buffer queue to get better frame timing."]
    #[doc = ""]
    #[doc = " 'format' used to be an ovrTextureFormat but has been expanded to accept"]
    #[doc = " platform specific format types. For GLES, this is the internal format."]
    #[doc = " If an unsupported format is provided, swapchain creation will fail."]
    #[doc = ""]
    #[doc = " SwapChain creation failures result in a return value of 'nullptr'."]
    pub fn vrapi_CreateTextureSwapChain3(
        type_: ovrTextureType,
        format: i64,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain2(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        bufferCount: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateTextureSwapChain(
        type_: ovrTextureType,
        format: ovrTextureFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        levels: ::std::os::raw::c_int,
        buffered: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Create an Android SurfaceTexture based texture swap chain suitable for use with vrapi_SubmitFrame."]
    #[doc = " Updating of the SurfaceTexture is handled through normal Android platform specific mechanisms"]
    #[doc = " from within the Compositor. A reference to the Android Surface object associated with the SurfaceTexture"]
    #[doc = " may be obtained by calling vrapi_GetTextureSwapChainAndroidSurface."]
    #[doc = ""]
    #[doc = " An optional width and height (ie width and height do not equal zero) may be provided in order to set"]
    #[doc = " the default size of the image buffers."]
    #[doc = " Note that the image producer may override the buffer size, in which case the default values provided"]
    #[doc = " here will not be used (ie both video decompression or camera preview override the size automatically)."]
    #[doc = ""]
    #[doc = " If isProtected is true, the surface swapchain will be created as a protected surface, ie for supporting"]
    #[doc = " secure video playback."]
    #[doc = ""]
    #[doc = " NOTE: These paths are not currently supported under Vulkan."]
    pub fn vrapi_CreateAndroidSurfaceSwapChain(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    pub fn vrapi_CreateAndroidSurfaceSwapChain2(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        isProtected: bool,
    ) -> *mut ovrTextureSwapChain;
}
extern "C" {
    #[doc = " Destroy the given texture swap chain."]
    #[doc = " Must be called from a thread with the same OpenGL ES context current when vrapi_CreateTextureSwapChain was called."]
    pub fn vrapi_DestroyTextureSwapChain(chain: *mut ovrTextureSwapChain);
}
extern "C" {
    #[doc = " Returns the number of textures in the swap chain."]
    pub fn vrapi_GetTextureSwapChainLength(
        chain: *mut ovrTextureSwapChain,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the OpenGL name of the texture at the given index."]
    pub fn vrapi_GetTextureSwapChainHandle(
        chain: *mut ovrTextureSwapChain,
        index: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the Android Surface object associated with the swap chain."]
    pub fn vrapi_GetTextureSwapChainAndroidSurface(chain: *mut ovrTextureSwapChain) -> jobject;
}
extern "C" {
    #[doc = " Accepts new eye images plus poses that will be used for future warps."]
    #[doc = " The parms are copied, and are not referenced after the function returns."]
    #[doc = ""]
    #[doc = " This will block until the textures from the previous vrapi_SubmitFrame() have been"]
    #[doc = " consumed by the background thread, to allow one frame of overlap for maximum"]
    #[doc = " GPU utilization, while preventing multiple frames from piling up variable latency."]
    #[doc = ""]
    #[doc = " This will block until at least SwapInterval vsyncs have passed since the last"]
    #[doc = " call to vrapi_SubmitFrame() to prevent applications with simple scenes from"]
    #[doc = " generating completely wasted frames."]
    #[doc = ""]
    #[doc = " IMPORTANT: any dynamic textures that are passed to vrapi_SubmitFrame() must be"]
    #[doc = " triple buffered to avoid flickering and performance problems."]
    #[doc = ""]
    #[doc = " The VrApi allows for one frame of overlap which is essential on tiled mobile GPUs."]
    #[doc = " Because there is one frame of overlap, the eye images have typically not completed"]
    #[doc = " rendering by the time they are submitted to vrapi_SubmitFrame(). To allow the time"]
    #[doc = " warp to check whether the eye images have completed rendering, vrapi_SubmitFrame()"]
    #[doc = " adds a sync object to the current context. Therefore, vrapi_SubmitFrame() *must*"]
    #[doc = " be called from a thread with an OpenGL ES context whose completion ensures that"]
    #[doc = " frame rendering is complete. Generally this is the thread and context that was used"]
    #[doc = " for the rendering."]
    pub fn vrapi_SubmitFrame(ovr: *mut ovrMobile, parms: *const ovrFrameParms);
}
extern "C" {
    #[doc = " vrapi_SubmitFrame2 takes a frameDescription describing per-frame information such as:"]
    #[doc = " a flexible list of layers which should be drawn this frame and a frame index."]
    pub fn vrapi_SubmitFrame2(
        ovr: *mut ovrMobile,
        frameDescription: *const ovrSubmitFrameDescription2,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Set the CPU and GPU performance levels."]
    #[doc = ""]
    #[doc = " Increasing the levels increases performance at the cost of higher power consumption"]
    #[doc = " which likely leads to a greater chance of overheating."]
    #[doc = ""]
    #[doc = " Levels will be clamped to the expected range. Default clock levels are cpuLevel = 2, gpuLevel = 2."]
    pub fn vrapi_SetClockLevels(ovr: *mut ovrMobile, cpuLevel: i32, gpuLevel: i32) -> ovrResult;
}
extern "C" {
    #[doc = " Specify which app threads should be given higher scheduling priority."]
    pub fn vrapi_SetPerfThread(
        ovr: *mut ovrMobile,
        type_: ovrPerfThreadType,
        threadId: u32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " If VRAPI_EXTRA_LATENCY_MODE_ON specified, adds an extra frame of latency for full GPU utilization."]
    #[doc = " Default is VRAPI_EXTRA_LATENCY_MODE_OFF."]
    #[doc = ""]
    #[doc = " The latency mode specified will be applied on the next call to vrapi_SubmitFrame(2)."]
    pub fn vrapi_SetExtraLatencyMode(ovr: *mut ovrMobile, mode: ovrExtraLatencyMode) -> ovrResult;
}
extern "C" {
    #[doc = " Set the Display Refresh Rate."]
    #[doc = " Returns ovrSuccess or an ovrError code."]
    #[doc = " Returns 'ovrError_InvalidParameter' if requested refresh rate is not supported by the device."]
    #[doc = " Returns 'ovrError_InvalidOperation' if the display refresh rate request was not allowed (such as when the device is in low power mode)."]
    pub fn vrapi_SetDisplayRefreshRate(ovr: *mut ovrMobile, refreshRate: f32) -> ovrResult;
}
#[repr(u32)]
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are never"]
#[doc = " reported to applications."]
#[doc = " ovrButton_Back button has system-level handling for long presses, but application-level handling for"]
#[doc = " short-presses. Since a short-press is determined by the time interval between down and up events, the"]
#[doc = " ovrButton_Back flag is only set when the back button comes up in less than the short-press time (0.25"]
#[doc = " seconds). The ovrButton_Back flag always signals a short press and will only remain set for a single frame."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrButton_ {
    ovrButton_A = 1,
    ovrButton_B = 2,
    ovrButton_RThumb = 4,
    ovrButton_RShoulder = 8,
    ovrButton_X = 256,
    ovrButton_Y = 512,
    ovrButton_LThumb = 1024,
    ovrButton_LShoulder = 2048,
    ovrButton_Up = 65536,
    ovrButton_Down = 131072,
    ovrButton_Left = 262144,
    ovrButton_Right = 524288,
    ovrButton_Enter = 1048576,
    ovrButton_Back = 2097152,
    ovrButton_GripTrigger = 67108864,
    ovrButton_Trigger = 536870912,
    ovrButton_Joystick = 2147483648,
    ovrButton_EnumSize = 2147483647,
}
#[doc = " Describes button input types."]
#[doc = " For the Gear VR Controller and headset, only the following ovrButton types are reported to the application:"]
#[doc = ""]
#[doc = " ovrButton_Back, ovrButton_A, ovrButton_Enter"]
#[doc = ""]
#[doc = " ovrButton_Home, ovrButton_VolUp, ovrButtonVolDown and ovrButton_Back are system buttons that are never"]
#[doc = " reported to applications."]
#[doc = " ovrButton_Back button has system-level handling for long presses, but application-level handling for"]
#[doc = " short-presses. Since a short-press is determined by the time interval between down and up events, the"]
#[doc = " ovrButton_Back flag is only set when the back button comes up in less than the short-press time (0.25"]
#[doc = " seconds). The ovrButton_Back flag always signals a short press and will only remain set for a single frame."]
pub use self::ovrButton_ as ovrButton;
#[repr(u32)]
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrTouch_ {
    ovrTouch_A = 1,
    ovrTouch_B = 2,
    ovrTouch_X = 4,
    ovrTouch_Y = 8,
    ovrTouch_TrackPad = 16,
    ovrTouch_Joystick = 32,
    ovrTouch_IndexTrigger = 64,
    ovrTouch_ThumbUp = 256,
    ovrTouch_IndexPointing = 512,
    ovrTouch_BaseState = 768,
    ovrTouch_LThumb = 1024,
    ovrTouch_RThumb = 2048,
    ovrTouch_EnumSize = 2049,
}
#[doc = " Describes touch input types."]
#[doc = " These values map to capacitive touch values and derived pose states"]
pub use self::ovrTouch_ as ovrTouch;
#[repr(u32)]
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerType_ {
    ovrControllerType_None = 0,
    ovrControllerType_Reserved0 = 1,
    ovrControllerType_Reserved1 = 2,
    ovrControllerType_TrackedRemote = 4,
    ovrControllerType_Headset = 8,
    ovrControllerType_Gamepad = 16,
    ovrControllerType_EnumSize = 2147483647,
}
#[doc = " Specifies which controller is connected; multiple can be connected at once."]
pub use self::ovrControllerType_ as ovrControllerType;
pub type ovrDeviceID = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrDeviceIdType_ {
    ovrDeviceIdType_Invalid = 2147483647,
}
pub use self::ovrDeviceIdType_ as ovrDeviceIdType;
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputCapabilityHeader_ {
    pub Type: ovrControllerType,
    #[doc = " A unique ID for the input device"]
    pub DeviceID: ovrDeviceID,
}
#[test]
fn bindgen_test_layout_ovrInputCapabilityHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputCapabilityHeader_>(),
        8usize,
        concat!("Size of: ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputCapabilityHeader_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputCapabilityHeader_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputCapabilityHeader_>())).DeviceID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputCapabilityHeader_),
            "::",
            stringify!(DeviceID)
        )
    );
}
#[doc = " This header starts all ovrInputCapabilities structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputCapabilityHeader = ovrInputCapabilityHeader_;
#[repr(u32)]
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrControllerCapabilities_ {
    ovrControllerCaps_HasOrientationTracking = 1,
    ovrControllerCaps_HasPositionTracking = 2,
    ovrControllerCaps_LeftHand = 4,
    ovrControllerCaps_RightHand = 8,
    ovrControllerCaps_ModelOculusGo = 16,
    ovrControllerCaps_HasAnalogIndexTrigger = 64,
    ovrControllerCaps_HasAnalogGripTrigger = 128,
    ovrControllerCaps_HasSimpleHapticVibration = 512,
    ovrControllerCaps_HasBufferedHapticVibration = 1024,
    ovrControllerCaps_ModelGearVR = 2048,
    ovrControllerCaps_HasTrackpad = 4096,
    ovrControllerCaps_HasJoystick = 8192,
    ovrControllerCaps_ModelOculusTouch = 16384,
    ovrControllerCaps_EnumSize = 2147483647,
}
#[doc = " Specifies capabilites of a controller"]
#[doc = " Note that left and right hand are non-exclusive (a two-handed controller could set both)"]
pub use self::ovrControllerCapabilities_ as ovrControllerCapabilties;
#[doc = " Details about the Oculus Remote input device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputTrackedRemoteCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    #[doc = " Maximum coordinates of the Trackpad, bottom right exclusive"]
    #[doc = " For a 300x200 Trackpad, return 299x199"]
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    #[doc = " Size of the Trackpad in mm (millimeters)"]
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
    #[doc = " added in API version 1.1.13.0"]
    #[doc = " Maximum submittable samples for the haptics buffer"]
    pub HapticSamplesMax: u32,
    #[doc = " length in milliseconds of a sample in the haptics buffer."]
    pub HapticSampleDurationMS: u32,
    #[doc = " added in API version 1.1.15.0"]
    pub TouchCapabilities: u32,
    pub Reserved4: u32,
    pub Reserved5: u32,
}
#[test]
fn bindgen_test_layout_ovrInputTrackedRemoteCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputTrackedRemoteCapabilities_>(),
        48usize,
        concat!("Size of: ", stringify!(ovrInputTrackedRemoteCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputTrackedRemoteCapabilities_>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ovrInputTrackedRemoteCapabilities_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).ButtonCapabilities
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxX as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadMaxY as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadMaxY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TrackpadSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TrackpadSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSamplesMax
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSamplesMax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).HapticSampleDurationMS
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(HapticSampleDurationMS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).TouchCapabilities
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(TouchCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved4 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputTrackedRemoteCapabilities_>())).Reserved5 as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputTrackedRemoteCapabilities_),
            "::",
            stringify!(Reserved5)
        )
    );
}
#[doc = " Details about the Oculus Remote input device."]
pub type ovrInputTrackedRemoteCapabilities = ovrInputTrackedRemoteCapabilities_;
#[doc = " Capabilities for the Head Mounted Tracking device (i.e. the headset)."]
#[doc = " Note that the GearVR headset firmware always sends relative coordinates"]
#[doc = " with the initial touch position offset by (1280,720). There is no way"]
#[doc = " to get purely raw coordinates from the headset. In addition, these"]
#[doc = " coordinates get adjusted for acceleration resulting in a slow movement"]
#[doc = " from one edge to the other the having a coordinate range of about 300"]
#[doc = " units, while a fast movement from edge to edge may result in a range"]
#[doc = " close to 900 units."]
#[doc = " This means the headset touchpad needs to be handled differently than"]
#[doc = " the GearVR Controller touchpad."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputHeadsetCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    #[doc = " Maximum coordinates of the Trackpad, bottom right exclusive"]
    #[doc = " For a 300x200 Trackpad, return 299x199"]
    pub TrackpadMaxX: u16,
    pub TrackpadMaxY: u16,
    #[doc = " Size of the Trackpad in mm (millimeters)"]
    pub TrackpadSizeX: f32,
    pub TrackpadSizeY: f32,
}
#[test]
fn bindgen_test_layout_ovrInputHeadsetCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputHeadsetCapabilities_>(),
        28usize,
        concat!("Size of: ", stringify!(ovrInputHeadsetCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputHeadsetCapabilities_>(),
        4usize,
        concat!("Alignment of ", stringify!(ovrInputHeadsetCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).ButtonCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadMaxX as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadMaxX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadMaxY as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadMaxY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputHeadsetCapabilities_>())).TrackpadSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputHeadsetCapabilities_),
            "::",
            stringify!(TrackpadSizeY)
        )
    );
}
#[doc = " Capabilities for the Head Mounted Tracking device (i.e. the headset)."]
#[doc = " Note that the GearVR headset firmware always sends relative coordinates"]
#[doc = " with the initial touch position offset by (1280,720). There is no way"]
#[doc = " to get purely raw coordinates from the headset. In addition, these"]
#[doc = " coordinates get adjusted for acceleration resulting in a slow movement"]
#[doc = " from one edge to the other the having a coordinate range of about 300"]
#[doc = " units, while a fast movement from edge to edge may result in a range"]
#[doc = " close to 900 units."]
#[doc = " This means the headset touchpad needs to be handled differently than"]
#[doc = " the GearVR Controller touchpad."]
pub type ovrInputHeadsetCapabilities = ovrInputHeadsetCapabilities_;
#[doc = " Capabilities for an XBox style game pad"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputGamepadCapabilities_ {
    pub Header: ovrInputCapabilityHeader,
    #[doc = " Mask of controller capabilities described by ovrControllerCapabilities"]
    pub ControllerCapabilities: u32,
    #[doc = " Mask of button capabilities described by ovrButton"]
    pub ButtonCapabilities: u32,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputGamepadCapabilities_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputGamepadCapabilities_>(),
        176usize,
        concat!("Size of: ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputGamepadCapabilities_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputGamepadCapabilities_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ControllerCapabilities
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ControllerCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).ButtonCapabilities as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(ButtonCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputGamepadCapabilities_>())).Reserved as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputGamepadCapabilities_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " Capabilities for an XBox style game pad"]
pub type ovrInputGamepadCapabilities = ovrInputGamepadCapabilities_;
#[doc = " The buffer data for playing haptics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrHapticBuffer_ {
    #[doc = " Start time of the buffer"]
    pub BufferTime: f64,
    #[doc = " Number of samples in the buffer;"]
    pub NumSamples: u32,
    pub Terminated: bool,
    pub HapticBuffer: *mut u8,
}
#[test]
fn bindgen_test_layout_ovrHapticBuffer_() {
    assert_eq!(
        ::std::mem::size_of::<ovrHapticBuffer_>(),
        24usize,
        concat!("Size of: ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrHapticBuffer_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrHapticBuffer_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).BufferTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(BufferTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).NumSamples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(NumSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).Terminated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(Terminated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrHapticBuffer_>())).HapticBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrHapticBuffer_),
            "::",
            stringify!(HapticBuffer)
        )
    );
}
#[doc = " The buffer data for playing haptics"]
pub type ovrHapticBuffer = ovrHapticBuffer_;
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateHeader_ {
    #[doc = " Type type of controller"]
    pub ControllerType: ovrControllerType,
    #[doc = " System time when the controller state was last updated."]
    pub TimeInSeconds: f64,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeader_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHeader_>(),
        16usize,
        concat!("Size of: ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHeader_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHeader_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).ControllerType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(ControllerType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeader_>())).TimeInSeconds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeader_),
            "::",
            stringify!(TimeInSeconds)
        )
    );
}
#[doc = " This header starts all ovrInputState structures. It should only hold fields"]
#[doc = " that are common to all input controllers."]
pub type ovrInputStateHeader = ovrInputStateHeader_;
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateTrackedRemote_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    #[doc = " Finger contact status for trackpad"]
    #[doc = " true = finger is on trackpad, false = finger is off trackpad"]
    pub TrackpadStatus: u32,
    #[doc = " X and Y coordinates of the Trackpad"]
    pub TrackpadPosition: ovrVector2f,
    #[doc = " The percentage of max battery charge remaining."]
    pub BatteryPercentRemaining: u8,
    #[doc = " Increments every time the remote is recentered. If this changes, the application may need"]
    #[doc = " to adjust its arm model accordingly."]
    pub RecenterCount: u8,
    #[doc = " Reserved for future use."]
    pub Reserved: u16,
    #[doc = " added in API version 1.1.13.0"]
    pub IndexTrigger: f32,
    pub GripTrigger: f32,
    #[doc = " added in API version 1.1.15.0"]
    pub Touches: u32,
    pub Reserved5a: u32,
    pub Joystick: ovrVector2f,
    pub JoystickNoDeadZone: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateTrackedRemote_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateTrackedRemote_>(),
        72usize,
        concat!("Size of: ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateTrackedRemote_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateTrackedRemote_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Buttons as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadStatus as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).TrackpadPosition as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(TrackpadPosition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).BatteryPercentRemaining
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(BatteryPercentRemaining)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).RecenterCount as *const _
                as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(RecenterCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).IndexTrigger as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(IndexTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).GripTrigger as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(GripTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Touches as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Touches)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Reserved5a as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Reserved5a)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).Joystick as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(Joystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateTrackedRemote_>())).JoystickNoDeadZone as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateTrackedRemote_),
            "::",
            stringify!(JoystickNoDeadZone)
        )
    );
}
#[doc = " ovrInputStateTrackedRemote describes the complete input state for the"]
#[doc = " orientation-tracked remote. The TrackpadPosition coordinates returned"]
#[doc = " for the GearVR Controller are in raw, absolute units."]
pub type ovrInputStateTrackedRemote = ovrInputStateTrackedRemote_;
#[doc = " ovrInputStateHeadset describes the complete input state for the"]
#[doc = " GearVR headset. The TrackpadPosition coordinates return for the"]
#[doc = " headset are relative coordinates, centered at (1280,720). See the"]
#[doc = " comments on ovrInputHeadsetCapabilities for more information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateHeadset_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    #[doc = " finger contact status for trackpad"]
    #[doc = " true = finger is on trackpad, false = finger is off trackpad"]
    pub TrackpadStatus: u32,
    #[doc = " X and Y coordinates of the Trackpad"]
    pub TrackpadPosition: ovrVector2f,
}
#[test]
fn bindgen_test_layout_ovrInputStateHeadset_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateHeadset_>(),
        32usize,
        concat!("Size of: ", stringify!(ovrInputStateHeadset_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateHeadset_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateHeadset_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHeadset_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateHeadset_>())).Buttons as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeadset_>())).TrackpadStatus as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(TrackpadStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateHeadset_>())).TrackpadPosition as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateHeadset_),
            "::",
            stringify!(TrackpadPosition)
        )
    );
}
#[doc = " ovrInputStateHeadset describes the complete input state for the"]
#[doc = " GearVR headset. The TrackpadPosition coordinates return for the"]
#[doc = " headset are relative coordinates, centered at (1280,720). See the"]
#[doc = " comments on ovrInputHeadsetCapabilities for more information."]
pub type ovrInputStateHeadset = ovrInputStateHeadset_;
#[doc = " ovrInputStateGamepad describes the input state gamepad input devices"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ovrInputStateGamepad_ {
    pub Header: ovrInputStateHeader,
    #[doc = " Values for buttons described by ovrButton."]
    pub Buttons: u32,
    pub LeftTrigger: f32,
    pub RightTrigger: f32,
    #[doc = " X and Y coordinates of the Left Joystick, -1.0 - 1.0"]
    pub LeftJoystick: ovrVector2f,
    #[doc = " X and Y coordinates of the Right Joystick, -1.0 - 1.0"]
    pub RightJoystick: ovrVector2f,
    pub Reserved: [u64; 20usize],
}
#[test]
fn bindgen_test_layout_ovrInputStateGamepad_() {
    assert_eq!(
        ::std::mem::size_of::<ovrInputStateGamepad_>(),
        208usize,
        concat!("Size of: ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        ::std::mem::align_of::<ovrInputStateGamepad_>(),
        8usize,
        concat!("Alignment of ", stringify!(ovrInputStateGamepad_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Buttons as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Buttons)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftTrigger as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightTrigger as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightTrigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).LeftJoystick as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(LeftJoystick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ovrInputStateGamepad_>())).RightJoystick as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(RightJoystick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ovrInputStateGamepad_>())).Reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ovrInputStateGamepad_),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " ovrInputStateGamepad describes the input state gamepad input devices"]
pub type ovrInputStateGamepad = ovrInputStateGamepad_;
extern "C" {
    #[doc = " Enumerates the input devices connected to the system"]
    #[doc = " Start with index=0 and counting up. Stop when ovrResult is < 0"]
    #[doc = ""]
    #[doc = " Input: ovrMobile, device index, and a capabilities header"]
    #[doc = " The capabilities header does not need to have any fields set before calling."]
    #[doc = " Output: capabilitiesHeader with information for that enumeration index"]
    pub fn vrapi_EnumerateInputDevices(
        ovr: *mut ovrMobile,
        index: u32,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the capabilities of the input device for the corresponding device ID"]
    #[doc = ""]
    #[doc = " Input: ovr, pointer to a capabilities structure"]
    #[doc = " Output: capabilities will be filled with information for the deviceID"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the capabilitiesHeader must be set when calling this function."]
    #[doc = "     Normally the capabilitiesHeader is obtained from the vrapi_EnumerateInputDevices API"]
    #[doc = "     The Type field in the header should match the structure type that is passed."]
    #[doc = ""]
    #[doc = "         ovrInputCapabilityHeader capsHeader;"]
    #[doc = "         if ( vrapi_EnumerateInputDevices( ovr, deviceIndex, &capsHeader ) >= 0 ) {"]
    #[doc = "             if ( capsHeader.Type == ovrDeviceType_TrackedRemote ) {"]
    #[doc = "                 ovrInputTrackedRemoteCapabilities remoteCaps;"]
    #[doc = "                 remoteCaps.Header = capsHeader;"]
    #[doc = "                 vrapi_GetInputDeviceCapabilities( ovr, &remoteCaps.Header );"]
    pub fn vrapi_GetInputDeviceCapabilities(
        ovr: *mut ovrMobile,
        capsHeader: *mut ovrInputCapabilityHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Sets the vibration level of a haptic device."]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, intensity: 0.0 - 1.0"]
    pub fn vrapi_SetHapticVibrationSimple(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        intensity: f32,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Fills the haptic vibration buffer of a haptic device"]
    #[doc = " there should only be one call to vrapi_SetHapticVibrationSimple or vrapi_SetHapticVibrationBuffer per frame"]
    #[doc = "  additional calls of either will return ovrError_InvalidOperation and have undefined behavior"]
    #[doc = " Input: ovr, deviceID, pointer to a hapticBuffer with filled in data."]
    pub fn vrapi_SetHapticVibrationBuffer(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        hapticBuffer: *const ovrHapticBuffer,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the current input state for controllers, without positional tracking info."]
    #[doc = ""]
    #[doc = " Input: ovr, deviceID, pointer to a capabilities structure (with Type field set)"]
    #[doc = " Output: Upon return the inputState structure will be set to the device's current input state"]
    #[doc = " Example:"]
    #[doc = "     The Type field of the passed ovrInputStateHeader must be set to the type that"]
    #[doc = "     corresponds to the type of structure being passed."]
    #[doc = "     The pointer to the ovrInputStateHeader should be a pointer to a Header field in"]
    #[doc = "     structure matching the value of the Type field."]
    #[doc = ""]
    #[doc = "     ovrInputStateTrackedRemote state;"]
    #[doc = "     state.Header.Type = ovrControllerType_TrackedRemote;"]
    #[doc = "     if ( vrapi_GetCurrentInputState( ovr, remoteDeviceID, &state.Header ) >= 0 ) {"]
    pub fn vrapi_GetCurrentInputState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        inputState: *mut ovrInputStateHeader,
    ) -> ovrResult;
}
extern "C" {
    #[doc = " Returns the predicted input state based on the specified absolute system time"]
    #[doc = " in seconds. Pass absTime value of 0.0 to request the most recent sensor reading."]
    #[doc = " Input: ovr, device ID, prediction time"]
    #[doc = " Output: ovrTracking structure containing the device's predicted tracking state."]
    pub fn vrapi_GetInputTrackingState(
        ovr: *mut ovrMobile,
        deviceID: ovrDeviceID,
        absTimeInSeconds: f64,
        tracking: *mut ovrTracking,
    ) -> ovrResult;
}
extern "C" {
    pub fn vrapi_RecenterInputPose(ovr: *mut ovrMobile, deviceID: ovrDeviceID);
}
extern "C" {
    #[doc = " Enable or disable emulation for the GearVR Controller."]
    #[doc = " Emulation is false by default."]
    #[doc = " If emulationOn == true, then the back button and touch events on the GearVR Controller will be sent through the Android"]
    #[doc = " dispatchKeyEvent and dispatchTouchEvent path as if they were from the headset back button and touchpad."]
    #[doc = " Applications that are intentionally enumerating the controller will likely want to turn emulation off in order"]
    #[doc = " to differentiate between controller and headset input events."]
    pub fn vrapi_SetRemoteEmulation(ovr: *mut ovrMobile, emulationOn: bool) -> ovrResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ovrFrameInit {
    VRAPI_FRAME_INIT_DEFAULT = 0,
    VRAPI_FRAME_INIT_BLACK = 1,
    VRAPI_FRAME_INIT_BLACK_FLUSH = 2,
    VRAPI_FRAME_INIT_BLACK_FINAL = 3,
    VRAPI_FRAME_INIT_LOADING_ICON = 4,
    VRAPI_FRAME_INIT_LOADING_ICON_FLUSH = 5,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
